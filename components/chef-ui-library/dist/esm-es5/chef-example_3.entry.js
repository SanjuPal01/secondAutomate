import { r as registerInstance, h, c as getElement } from './chunk-efdec40a.js';
import { c as createCommonjsModule, a as commonjsGlobal } from './chunk-d7ac2f15.js';
/**
 * @description
 * The `<chef-example>` molecule is used to display syntax-highlighted example code alongside their
 * rendered output.
 *
 * @example
 * <chef-example code="<h1>Highlight me</h1>"></chef-example>
 */
var ChefExample = /** @class */ (function () {
    function ChefExample(hostRef) {
        registerInstance(this, hostRef);
    }
    ChefExample.prototype.componentDidLoad = function () {
        this.execScripts();
    };
    ChefExample.prototype.componentDidUpdate = function () {
        this.execScripts();
    };
    ChefExample.prototype.render = function () {
        return ([
            h("chef-snippet", { class: "example-code", code: this.code }),
            h("div", { class: "example-display", innerHTML: this.code })
        ]);
    };
    ChefExample.prototype.execScripts = function () {
        var scripts = Array.from(this.el.querySelectorAll('script'));
        return scripts.map(function (script) { return new Function(script.innerText)(); });
    };
    Object.defineProperty(ChefExample.prototype, "el", {
        get: function () { return getElement(this); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChefExample, "style", {
        get: function () { return "chef-example{--border-color:var(--chef-grey);display:block;margin:1em 0;border:1px solid var(--border-color)}chef-example .example-code{border-bottom:1px solid var(--chef-grey)}chef-example .example-display{padding:1em}"; },
        enumerable: true,
        configurable: true
    });
    return ChefExample;
}());
var marked = createCommonjsModule(function (module, exports) {
    (function (root) {
        /**
         * Block-Level Grammar
         */
        var block = {
            newline: /^\n+/,
            code: /^( {4}[^\n]+\n*)+/,
            fences: /^ {0,3}(`{3,}|~{3,})([^`~\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?:\n+|$)|$)/,
            hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
            heading: /^ {0,3}(#{1,6}) +([^\n]*?)(?: +#+)? *(?:\n+|$)/,
            blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
            list: /^( {0,3})(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
            html: '^ {0,3}(?:' // optional indentation
                + '<(script|pre|style)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)' // (1)
                + '|comment[^\\n]*(\\n+|$)' // (2)
                + '|<\\?[\\s\\S]*?\\?>\\n*' // (3)
                + '|<![A-Z][\\s\\S]*?>\\n*' // (4)
                + '|<!\\[CDATA\\[[\\s\\S]*?\\]\\]>\\n*' // (5)
                + '|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:\\n{2,}|$)' // (6)
                + '|<(?!script|pre|style)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$)' // (7) open tag
                + '|</(?!script|pre|style)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$)' // (7) closing tag
                + ')',
            def: /^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/,
            nptable: noop,
            table: noop,
            lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
            // regex template, placeholders will be replaced according to different paragraph
            // interruption rules of commonmark and the original markdown spec:
            _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html)[^\n]+)*)/,
            text: /^[^\n]+/
        };
        block._label = /(?!\s*\])(?:\\[\[\]]|[^\[\]])+/;
        block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
        block.def = edit(block.def)
            .replace('label', block._label)
            .replace('title', block._title)
            .getRegex();
        block.bullet = /(?:[*+-]|\d{1,9}\.)/;
        block.item = /^( *)(bull) ?[^\n]*(?:\n(?!\1bull ?)[^\n]*)*/;
        block.item = edit(block.item, 'gm')
            .replace(/bull/g, block.bullet)
            .getRegex();
        block.list = edit(block.list)
            .replace(/bull/g, block.bullet)
            .replace('hr', '\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))')
            .replace('def', '\\n+(?=' + block.def.source + ')')
            .getRegex();
        block._tag = 'address|article|aside|base|basefont|blockquote|body|caption'
            + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'
            + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'
            + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'
            + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr'
            + '|track|ul';
        block._comment = /<!--(?!-?>)[\s\S]*?-->/;
        block.html = edit(block.html, 'i')
            .replace('comment', block._comment)
            .replace('tag', block._tag)
            .replace('attribute', / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/)
            .getRegex();
        block.paragraph = edit(block._paragraph)
            .replace('hr', block.hr)
            .replace('heading', ' {0,3}#{1,6} +')
            .replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs
            .replace('blockquote', ' {0,3}>')
            .replace('fences', ' {0,3}(?:`{3,}|~{3,})[^`\\n]*\\n')
            .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
            .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)')
            .replace('tag', block._tag) // pars can be interrupted by type (6) html blocks
            .getRegex();
        block.blockquote = edit(block.blockquote)
            .replace('paragraph', block.paragraph)
            .getRegex();
        /**
         * Normal Block Grammar
         */
        block.normal = merge({}, block);
        /**
         * GFM Block Grammar
         */
        block.gfm = merge({}, block.normal, {
            nptable: /^ *([^|\n ].*\|.*)\n *([-:]+ *\|[-| :]*)(?:\n((?:.*[^>\n ].*(?:\n|$))*)\n*|$)/,
            table: /^ *\|(.+)\n *\|?( *[-:]+[-| :]*)(?:\n((?: *[^>\n ].*(?:\n|$))*)\n*|$)/
        });
        /**
         * Pedantic grammar (original John Gruber's loose markdown specification)
         */
        block.pedantic = merge({}, block.normal, {
            html: edit('^ *(?:comment *(?:\\n|\\s*$)'
                + '|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)' // closed tag
                + '|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))')
                .replace('comment', block._comment)
                .replace(/tag/g, '(?!(?:'
                + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'
                + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'
                + '\\b)\\w+(?!:|[^\\w\\s@]*@)\\b')
                .getRegex(),
            def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
            heading: /^ *(#{1,6}) *([^\n]+?) *(?:#+ *)?(?:\n+|$)/,
            fences: noop,
            paragraph: edit(block.normal._paragraph)
                .replace('hr', block.hr)
                .replace('heading', ' *#{1,6} *[^\n]')
                .replace('lheading', block.lheading)
                .replace('blockquote', ' {0,3}>')
                .replace('|fences', '')
                .replace('|list', '')
                .replace('|html', '')
                .getRegex()
        });
        /**
         * Block Lexer
         */
        function Lexer(options) {
            this.tokens = [];
            this.tokens.links = Object.create(null);
            this.options = options || marked.defaults;
            this.rules = block.normal;
            if (this.options.pedantic) {
                this.rules = block.pedantic;
            }
            else if (this.options.gfm) {
                this.rules = block.gfm;
            }
        }
        /**
         * Expose Block Rules
         */
        Lexer.rules = block;
        /**
         * Static Lex Method
         */
        Lexer.lex = function (src, options) {
            var lexer = new Lexer(options);
            return lexer.lex(src);
        };
        /**
         * Preprocessing
         */
        Lexer.prototype.lex = function (src) {
            src = src
                .replace(/\r\n|\r/g, '\n')
                .replace(/\t/g, '    ')
                .replace(/\u00a0/g, ' ')
                .replace(/\u2424/g, '\n');
            return this.token(src, true);
        };
        /**
         * Lexing
         */
        Lexer.prototype.token = function (src, top) {
            src = src.replace(/^ +$/gm, '');
            var next, loose, cap, bull, b, item, listStart, listItems, t, space, i, tag, l, isordered, istask, ischecked;
            while (src) {
                // newline
                if (cap = this.rules.newline.exec(src)) {
                    src = src.substring(cap[0].length);
                    if (cap[0].length > 1) {
                        this.tokens.push({
                            type: 'space'
                        });
                    }
                }
                // code
                if (cap = this.rules.code.exec(src)) {
                    var lastToken = this.tokens[this.tokens.length - 1];
                    src = src.substring(cap[0].length);
                    // An indented code block cannot interrupt a paragraph.
                    if (lastToken && lastToken.type === 'paragraph') {
                        lastToken.text += '\n' + cap[0].trimRight();
                    }
                    else {
                        cap = cap[0].replace(/^ {4}/gm, '');
                        this.tokens.push({
                            type: 'code',
                            codeBlockStyle: 'indented',
                            text: !this.options.pedantic
                                ? rtrim(cap, '\n')
                                : cap
                        });
                    }
                    continue;
                }
                // fences
                if (cap = this.rules.fences.exec(src)) {
                    src = src.substring(cap[0].length);
                    this.tokens.push({
                        type: 'code',
                        lang: cap[2] ? cap[2].trim() : cap[2],
                        text: cap[3] || ''
                    });
                    continue;
                }
                // heading
                if (cap = this.rules.heading.exec(src)) {
                    src = src.substring(cap[0].length);
                    this.tokens.push({
                        type: 'heading',
                        depth: cap[1].length,
                        text: cap[2]
                    });
                    continue;
                }
                // table no leading pipe (gfm)
                if (cap = this.rules.nptable.exec(src)) {
                    item = {
                        type: 'table',
                        header: splitCells(cap[1].replace(/^ *| *\| *$/g, '')),
                        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
                        cells: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : []
                    };
                    if (item.header.length === item.align.length) {
                        src = src.substring(cap[0].length);
                        for (i = 0; i < item.align.length; i++) {
                            if (/^ *-+: *$/.test(item.align[i])) {
                                item.align[i] = 'right';
                            }
                            else if (/^ *:-+: *$/.test(item.align[i])) {
                                item.align[i] = 'center';
                            }
                            else if (/^ *:-+ *$/.test(item.align[i])) {
                                item.align[i] = 'left';
                            }
                            else {
                                item.align[i] = null;
                            }
                        }
                        for (i = 0; i < item.cells.length; i++) {
                            item.cells[i] = splitCells(item.cells[i], item.header.length);
                        }
                        this.tokens.push(item);
                        continue;
                    }
                }
                // hr
                if (cap = this.rules.hr.exec(src)) {
                    src = src.substring(cap[0].length);
                    this.tokens.push({
                        type: 'hr'
                    });
                    continue;
                }
                // blockquote
                if (cap = this.rules.blockquote.exec(src)) {
                    src = src.substring(cap[0].length);
                    this.tokens.push({
                        type: 'blockquote_start'
                    });
                    cap = cap[0].replace(/^ *> ?/gm, '');
                    // Pass `top` to keep the current
                    // "toplevel" state. This is exactly
                    // how markdown.pl works.
                    this.token(cap, top);
                    this.tokens.push({
                        type: 'blockquote_end'
                    });
                    continue;
                }
                // list
                if (cap = this.rules.list.exec(src)) {
                    src = src.substring(cap[0].length);
                    bull = cap[2];
                    isordered = bull.length > 1;
                    listStart = {
                        type: 'list_start',
                        ordered: isordered,
                        start: isordered ? +bull : '',
                        loose: false
                    };
                    this.tokens.push(listStart);
                    // Get each top-level item.
                    cap = cap[0].match(this.rules.item);
                    listItems = [];
                    next = false;
                    l = cap.length;
                    i = 0;
                    for (; i < l; i++) {
                        item = cap[i];
                        // Remove the list item's bullet
                        // so it is seen as the next token.
                        space = item.length;
                        item = item.replace(/^ *([*+-]|\d+\.) */, '');
                        // Outdent whatever the
                        // list item contains. Hacky.
                        if (~item.indexOf('\n ')) {
                            space -= item.length;
                            item = !this.options.pedantic
                                ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
                                : item.replace(/^ {1,4}/gm, '');
                        }
                        // Determine whether the next list item belongs here.
                        // Backpedal if it does not belong in this list.
                        if (i !== l - 1) {
                            b = block.bullet.exec(cap[i + 1])[0];
                            if (bull.length > 1 ? b.length === 1
                                : (b.length > 1 || (this.options.smartLists && b !== bull))) {
                                src = cap.slice(i + 1).join('\n') + src;
                                i = l - 1;
                            }
                        }
                        // Determine whether item is loose or not.
                        // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
                        // for discount behavior.
                        loose = next || /\n\n(?!\s*$)/.test(item);
                        if (i !== l - 1) {
                            next = item.charAt(item.length - 1) === '\n';
                            if (!loose)
                                loose = next;
                        }
                        if (loose) {
                            listStart.loose = true;
                        }
                        // Check for task list items
                        istask = /^\[[ xX]\] /.test(item);
                        ischecked = undefined;
                        if (istask) {
                            ischecked = item[1] !== ' ';
                            item = item.replace(/^\[[ xX]\] +/, '');
                        }
                        t = {
                            type: 'list_item_start',
                            task: istask,
                            checked: ischecked,
                            loose: loose
                        };
                        listItems.push(t);
                        this.tokens.push(t);
                        // Recurse.
                        this.token(item, false);
                        this.tokens.push({
                            type: 'list_item_end'
                        });
                    }
                    if (listStart.loose) {
                        l = listItems.length;
                        i = 0;
                        for (; i < l; i++) {
                            listItems[i].loose = true;
                        }
                    }
                    this.tokens.push({
                        type: 'list_end'
                    });
                    continue;
                }
                // html
                if (cap = this.rules.html.exec(src)) {
                    src = src.substring(cap[0].length);
                    this.tokens.push({
                        type: this.options.sanitize
                            ? 'paragraph'
                            : 'html',
                        pre: !this.options.sanitizer
                            && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
                        text: this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0])) : cap[0]
                    });
                    continue;
                }
                // def
                if (top && (cap = this.rules.def.exec(src))) {
                    src = src.substring(cap[0].length);
                    if (cap[3])
                        cap[3] = cap[3].substring(1, cap[3].length - 1);
                    tag = cap[1].toLowerCase().replace(/\s+/g, ' ');
                    if (!this.tokens.links[tag]) {
                        this.tokens.links[tag] = {
                            href: cap[2],
                            title: cap[3]
                        };
                    }
                    continue;
                }
                // table (gfm)
                if (cap = this.rules.table.exec(src)) {
                    item = {
                        type: 'table',
                        header: splitCells(cap[1].replace(/^ *| *\| *$/g, '')),
                        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
                        cells: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : []
                    };
                    if (item.header.length === item.align.length) {
                        src = src.substring(cap[0].length);
                        for (i = 0; i < item.align.length; i++) {
                            if (/^ *-+: *$/.test(item.align[i])) {
                                item.align[i] = 'right';
                            }
                            else if (/^ *:-+: *$/.test(item.align[i])) {
                                item.align[i] = 'center';
                            }
                            else if (/^ *:-+ *$/.test(item.align[i])) {
                                item.align[i] = 'left';
                            }
                            else {
                                item.align[i] = null;
                            }
                        }
                        for (i = 0; i < item.cells.length; i++) {
                            item.cells[i] = splitCells(item.cells[i].replace(/^ *\| *| *\| *$/g, ''), item.header.length);
                        }
                        this.tokens.push(item);
                        continue;
                    }
                }
                // lheading
                if (cap = this.rules.lheading.exec(src)) {
                    src = src.substring(cap[0].length);
                    this.tokens.push({
                        type: 'heading',
                        depth: cap[2].charAt(0) === '=' ? 1 : 2,
                        text: cap[1]
                    });
                    continue;
                }
                // top-level paragraph
                if (top && (cap = this.rules.paragraph.exec(src))) {
                    src = src.substring(cap[0].length);
                    this.tokens.push({
                        type: 'paragraph',
                        text: cap[1].charAt(cap[1].length - 1) === '\n'
                            ? cap[1].slice(0, -1)
                            : cap[1]
                    });
                    continue;
                }
                // text
                if (cap = this.rules.text.exec(src)) {
                    // Top-level should never reach here.
                    src = src.substring(cap[0].length);
                    this.tokens.push({
                        type: 'text',
                        text: cap[0]
                    });
                    continue;
                }
                if (src) {
                    throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
                }
            }
            return this.tokens;
        };
        /**
         * Inline-Level Grammar
         */
        var inline = {
            escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
            autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
            url: noop,
            tag: '^comment'
                + '|^</[a-zA-Z][\\w:-]*\\s*>' // self-closing tag
                + '|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>' // open tag
                + '|^<\\?[\\s\\S]*?\\?>' // processing instruction, e.g. <?php ?>
                + '|^<![a-zA-Z]+\\s[\\s\\S]*?>' // declaration, e.g. <!DOCTYPE html>
                + '|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>',
            link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
            reflink: /^!?\[(label)\]\[(?!\s*\])((?:\\[\[\]]?|[^\[\]\\])+)\]/,
            nolink: /^!?\[(?!\s*\])((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\](?:\[\])?/,
            strong: /^__([^\s_])__(?!_)|^\*\*([^\s*])\*\*(?!\*)|^__([^\s][\s\S]*?[^\s])__(?!_)|^\*\*([^\s][\s\S]*?[^\s])\*\*(?!\*)/,
            em: /^_([^\s_])_(?!_)|^\*([^\s*<\[])\*(?!\*)|^_([^\s<][\s\S]*?[^\s_])_(?!_|[^\spunctuation])|^_([^\s_<][\s\S]*?[^\s])_(?!_|[^\spunctuation])|^\*([^\s<"][\s\S]*?[^\s\*])\*(?!\*|[^\spunctuation])|^\*([^\s*"<\[][\s\S]*?[^\s])\*(?!\*)/,
            code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
            br: /^( {2,}|\\)\n(?!\s*$)/,
            del: noop,
            text: /^(`+|[^`])(?:[\s\S]*?(?:(?=[\\<!\[`*]|\b_|$)|[^ ](?= {2,}\n))|(?= {2,}\n))/
        };
        // list of punctuation marks from common mark spec
        // without ` and ] to workaround Rule 17 (inline code blocks/links)
        inline._punctuation = '!"#$%&\'()*+,\\-./:;<=>?@\\[^_{|}~';
        inline.em = edit(inline.em).replace(/punctuation/g, inline._punctuation).getRegex();
        inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
        inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
        inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
        inline.autolink = edit(inline.autolink)
            .replace('scheme', inline._scheme)
            .replace('email', inline._email)
            .getRegex();
        inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
        inline.tag = edit(inline.tag)
            .replace('comment', block._comment)
            .replace('attribute', inline._attribute)
            .getRegex();
        inline._label = /(?:\[[^\[\]]*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
        inline._href = /<(?:\\[<>]?|[^\s<>\\])*>|[^\s\x00-\x1f]*/;
        inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
        inline.link = edit(inline.link)
            .replace('label', inline._label)
            .replace('href', inline._href)
            .replace('title', inline._title)
            .getRegex();
        inline.reflink = edit(inline.reflink)
            .replace('label', inline._label)
            .getRegex();
        /**
         * Normal Inline Grammar
         */
        inline.normal = merge({}, inline);
        /**
         * Pedantic Inline Grammar
         */
        inline.pedantic = merge({}, inline.normal, {
            strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
            em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/,
            link: edit(/^!?\[(label)\]\((.*?)\)/)
                .replace('label', inline._label)
                .getRegex(),
            reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/)
                .replace('label', inline._label)
                .getRegex()
        });
        /**
         * GFM Inline Grammar
         */
        inline.gfm = merge({}, inline.normal, {
            escape: edit(inline.escape).replace('])', '~|])').getRegex(),
            _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
            url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
            _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
            del: /^~+(?=\S)([\s\S]*?\S)~+/,
            text: /^(`+|[^`])(?:[\s\S]*?(?:(?=[\\<!\[`*~]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))|(?= {2,}\n|[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))/
        });
        inline.gfm.url = edit(inline.gfm.url, 'i')
            .replace('email', inline.gfm._extended_email)
            .getRegex();
        /**
         * GFM + Line Breaks Inline Grammar
         */
        inline.breaks = merge({}, inline.gfm, {
            br: edit(inline.br).replace('{2,}', '*').getRegex(),
            text: edit(inline.gfm.text)
                .replace('\\b_', '\\b_| {2,}\\n')
                .replace(/\{2,\}/g, '*')
                .getRegex()
        });
        /**
         * Inline Lexer & Compiler
         */
        function InlineLexer(links, options) {
            this.options = options || marked.defaults;
            this.links = links;
            this.rules = inline.normal;
            this.renderer = this.options.renderer || new Renderer();
            this.renderer.options = this.options;
            if (!this.links) {
                throw new Error('Tokens array requires a `links` property.');
            }
            if (this.options.pedantic) {
                this.rules = inline.pedantic;
            }
            else if (this.options.gfm) {
                if (this.options.breaks) {
                    this.rules = inline.breaks;
                }
                else {
                    this.rules = inline.gfm;
                }
            }
        }
        /**
         * Expose Inline Rules
         */
        InlineLexer.rules = inline;
        /**
         * Static Lexing/Compiling Method
         */
        InlineLexer.output = function (src, links, options) {
            var inline = new InlineLexer(links, options);
            return inline.output(src);
        };
        /**
         * Lexing/Compiling
         */
        InlineLexer.prototype.output = function (src) {
            var out = '', link, text, href, title, cap, prevCapZero;
            while (src) {
                // escape
                if (cap = this.rules.escape.exec(src)) {
                    src = src.substring(cap[0].length);
                    out += escape(cap[1]);
                    continue;
                }
                // tag
                if (cap = this.rules.tag.exec(src)) {
                    if (!this.inLink && /^<a /i.test(cap[0])) {
                        this.inLink = true;
                    }
                    else if (this.inLink && /^<\/a>/i.test(cap[0])) {
                        this.inLink = false;
                    }
                    if (!this.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
                        this.inRawBlock = true;
                    }
                    else if (this.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
                        this.inRawBlock = false;
                    }
                    src = src.substring(cap[0].length);
                    out += this.options.sanitize
                        ? this.options.sanitizer
                            ? this.options.sanitizer(cap[0])
                            : escape(cap[0])
                        : cap[0];
                    continue;
                }
                // link
                if (cap = this.rules.link.exec(src)) {
                    var lastParenIndex = findClosingBracket(cap[2], '()');
                    if (lastParenIndex > -1) {
                        var linkLen = 4 + cap[1].length + lastParenIndex;
                        cap[2] = cap[2].substring(0, lastParenIndex);
                        cap[0] = cap[0].substring(0, linkLen).trim();
                        cap[3] = '';
                    }
                    src = src.substring(cap[0].length);
                    this.inLink = true;
                    href = cap[2];
                    if (this.options.pedantic) {
                        link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
                        if (link) {
                            href = link[1];
                            title = link[3];
                        }
                        else {
                            title = '';
                        }
                    }
                    else {
                        title = cap[3] ? cap[3].slice(1, -1) : '';
                    }
                    href = href.trim().replace(/^<([\s\S]*)>$/, '$1');
                    out += this.outputLink(cap, {
                        href: InlineLexer.escapes(href),
                        title: InlineLexer.escapes(title)
                    });
                    this.inLink = false;
                    continue;
                }
                // reflink, nolink
                if ((cap = this.rules.reflink.exec(src))
                    || (cap = this.rules.nolink.exec(src))) {
                    src = src.substring(cap[0].length);
                    link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
                    link = this.links[link.toLowerCase()];
                    if (!link || !link.href) {
                        out += cap[0].charAt(0);
                        src = cap[0].substring(1) + src;
                        continue;
                    }
                    this.inLink = true;
                    out += this.outputLink(cap, link);
                    this.inLink = false;
                    continue;
                }
                // strong
                if (cap = this.rules.strong.exec(src)) {
                    src = src.substring(cap[0].length);
                    out += this.renderer.strong(this.output(cap[4] || cap[3] || cap[2] || cap[1]));
                    continue;
                }
                // em
                if (cap = this.rules.em.exec(src)) {
                    src = src.substring(cap[0].length);
                    out += this.renderer.em(this.output(cap[6] || cap[5] || cap[4] || cap[3] || cap[2] || cap[1]));
                    continue;
                }
                // code
                if (cap = this.rules.code.exec(src)) {
                    src = src.substring(cap[0].length);
                    out += this.renderer.codespan(escape(cap[2].trim(), true));
                    continue;
                }
                // br
                if (cap = this.rules.br.exec(src)) {
                    src = src.substring(cap[0].length);
                    out += this.renderer.br();
                    continue;
                }
                // del (gfm)
                if (cap = this.rules.del.exec(src)) {
                    src = src.substring(cap[0].length);
                    out += this.renderer.del(this.output(cap[1]));
                    continue;
                }
                // autolink
                if (cap = this.rules.autolink.exec(src)) {
                    src = src.substring(cap[0].length);
                    if (cap[2] === '@') {
                        text = escape(this.mangle(cap[1]));
                        href = 'mailto:' + text;
                    }
                    else {
                        text = escape(cap[1]);
                        href = text;
                    }
                    out += this.renderer.link(href, null, text);
                    continue;
                }
                // url (gfm)
                if (!this.inLink && (cap = this.rules.url.exec(src))) {
                    if (cap[2] === '@') {
                        text = escape(cap[0]);
                        href = 'mailto:' + text;
                    }
                    else {
                        // do extended autolink path validation
                        do {
                            prevCapZero = cap[0];
                            cap[0] = this.rules._backpedal.exec(cap[0])[0];
                        } while (prevCapZero !== cap[0]);
                        text = escape(cap[0]);
                        if (cap[1] === 'www.') {
                            href = 'http://' + text;
                        }
                        else {
                            href = text;
                        }
                    }
                    src = src.substring(cap[0].length);
                    out += this.renderer.link(href, null, text);
                    continue;
                }
                // text
                if (cap = this.rules.text.exec(src)) {
                    src = src.substring(cap[0].length);
                    if (this.inRawBlock) {
                        out += this.renderer.text(this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0])) : cap[0]);
                    }
                    else {
                        out += this.renderer.text(escape(this.smartypants(cap[0])));
                    }
                    continue;
                }
                if (src) {
                    throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
                }
            }
            return out;
        };
        InlineLexer.escapes = function (text) {
            return text ? text.replace(InlineLexer.rules._escapes, '$1') : text;
        };
        /**
         * Compile Link
         */
        InlineLexer.prototype.outputLink = function (cap, link) {
            var href = link.href, title = link.title ? escape(link.title) : null;
            return cap[0].charAt(0) !== '!'
                ? this.renderer.link(href, title, this.output(cap[1]))
                : this.renderer.image(href, title, escape(cap[1]));
        };
        /**
         * Smartypants Transformations
         */
        InlineLexer.prototype.smartypants = function (text) {
            if (!this.options.smartypants)
                return text;
            return text
                // em-dashes
                .replace(/---/g, '\u2014')
                // en-dashes
                .replace(/--/g, '\u2013')
                // opening singles
                .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
                // closing singles & apostrophes
                .replace(/'/g, '\u2019')
                // opening doubles
                .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
                // closing doubles
                .replace(/"/g, '\u201d')
                // ellipses
                .replace(/\.{3}/g, '\u2026');
        };
        /**
         * Mangle Links
         */
        InlineLexer.prototype.mangle = function (text) {
            if (!this.options.mangle)
                return text;
            var out = '', l = text.length, i = 0, ch;
            for (; i < l; i++) {
                ch = text.charCodeAt(i);
                if (Math.random() > 0.5) {
                    ch = 'x' + ch.toString(16);
                }
                out += '&#' + ch + ';';
            }
            return out;
        };
        /**
         * Renderer
         */
        function Renderer(options) {
            this.options = options || marked.defaults;
        }
        Renderer.prototype.code = function (code, infostring, escaped) {
            var lang = (infostring || '').match(/\S*/)[0];
            if (this.options.highlight) {
                var out = this.options.highlight(code, lang);
                if (out != null && out !== code) {
                    escaped = true;
                    code = out;
                }
            }
            if (!lang) {
                return '<pre><code>'
                    + (escaped ? code : escape(code, true))
                    + '</code></pre>';
            }
            return '<pre><code class="'
                + this.options.langPrefix
                + escape(lang, true)
                + '">'
                + (escaped ? code : escape(code, true))
                + '</code></pre>\n';
        };
        Renderer.prototype.blockquote = function (quote) {
            return '<blockquote>\n' + quote + '</blockquote>\n';
        };
        Renderer.prototype.html = function (html) {
            return html;
        };
        Renderer.prototype.heading = function (text, level, raw, slugger) {
            if (this.options.headerIds) {
                return '<h'
                    + level
                    + ' id="'
                    + this.options.headerPrefix
                    + slugger.slug(raw)
                    + '">'
                    + text
                    + '</h'
                    + level
                    + '>\n';
            }
            // ignore IDs
            return '<h' + level + '>' + text + '</h' + level + '>\n';
        };
        Renderer.prototype.hr = function () {
            return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
        };
        Renderer.prototype.list = function (body, ordered, start) {
            var type = ordered ? 'ol' : 'ul', startatt = (ordered && start !== 1) ? (' start="' + start + '"') : '';
            return '<' + type + startatt + '>\n' + body + '</' + type + '>\n';
        };
        Renderer.prototype.listitem = function (text) {
            return '<li>' + text + '</li>\n';
        };
        Renderer.prototype.checkbox = function (checked) {
            return '<input '
                + (checked ? 'checked="" ' : '')
                + 'disabled="" type="checkbox"'
                + (this.options.xhtml ? ' /' : '')
                + '> ';
        };
        Renderer.prototype.paragraph = function (text) {
            return '<p>' + text + '</p>\n';
        };
        Renderer.prototype.table = function (header, body) {
            if (body)
                body = '<tbody>' + body + '</tbody>';
            return '<table>\n'
                + '<thead>\n'
                + header
                + '</thead>\n'
                + body
                + '</table>\n';
        };
        Renderer.prototype.tablerow = function (content) {
            return '<tr>\n' + content + '</tr>\n';
        };
        Renderer.prototype.tablecell = function (content, flags) {
            var type = flags.header ? 'th' : 'td';
            var tag = flags.align
                ? '<' + type + ' align="' + flags.align + '">'
                : '<' + type + '>';
            return tag + content + '</' + type + '>\n';
        };
        // span level renderer
        Renderer.prototype.strong = function (text) {
            return '<strong>' + text + '</strong>';
        };
        Renderer.prototype.em = function (text) {
            return '<em>' + text + '</em>';
        };
        Renderer.prototype.codespan = function (text) {
            return '<code>' + text + '</code>';
        };
        Renderer.prototype.br = function () {
            return this.options.xhtml ? '<br/>' : '<br>';
        };
        Renderer.prototype.del = function (text) {
            return '<del>' + text + '</del>';
        };
        Renderer.prototype.link = function (href, title, text) {
            href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
            if (href === null) {
                return text;
            }
            var out = '<a href="' + escape(href) + '"';
            if (title) {
                out += ' title="' + title + '"';
            }
            out += '>' + text + '</a>';
            return out;
        };
        Renderer.prototype.image = function (href, title, text) {
            href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
            if (href === null) {
                return text;
            }
            var out = '<img src="' + href + '" alt="' + text + '"';
            if (title) {
                out += ' title="' + title + '"';
            }
            out += this.options.xhtml ? '/>' : '>';
            return out;
        };
        Renderer.prototype.text = function (text) {
            return text;
        };
        /**
         * TextRenderer
         * returns only the textual part of the token
         */
        function TextRenderer() { }
        // no need for block level renderers
        TextRenderer.prototype.strong =
            TextRenderer.prototype.em =
                TextRenderer.prototype.codespan =
                    TextRenderer.prototype.del =
                        TextRenderer.prototype.text = function (text) {
                            return text;
                        };
        TextRenderer.prototype.link =
            TextRenderer.prototype.image = function (href, title, text) {
                return '' + text;
            };
        TextRenderer.prototype.br = function () {
            return '';
        };
        /**
         * Parsing & Compiling
         */
        function Parser(options) {
            this.tokens = [];
            this.token = null;
            this.options = options || marked.defaults;
            this.options.renderer = this.options.renderer || new Renderer();
            this.renderer = this.options.renderer;
            this.renderer.options = this.options;
            this.slugger = new Slugger();
        }
        /**
         * Static Parse Method
         */
        Parser.parse = function (src, options) {
            var parser = new Parser(options);
            return parser.parse(src);
        };
        /**
         * Parse Loop
         */
        Parser.prototype.parse = function (src) {
            this.inline = new InlineLexer(src.links, this.options);
            // use an InlineLexer with a TextRenderer to extract pure text
            this.inlineText = new InlineLexer(src.links, merge({}, this.options, { renderer: new TextRenderer() }));
            this.tokens = src.reverse();
            var out = '';
            while (this.next()) {
                out += this.tok();
            }
            return out;
        };
        /**
         * Next Token
         */
        Parser.prototype.next = function () {
            this.token = this.tokens.pop();
            return this.token;
        };
        /**
         * Preview Next Token
         */
        Parser.prototype.peek = function () {
            return this.tokens[this.tokens.length - 1] || 0;
        };
        /**
         * Parse Text Tokens
         */
        Parser.prototype.parseText = function () {
            var body = this.token.text;
            while (this.peek().type === 'text') {
                body += '\n' + this.next().text;
            }
            return this.inline.output(body);
        };
        /**
         * Parse Current Token
         */
        Parser.prototype.tok = function () {
            switch (this.token.type) {
                case 'space': {
                    return '';
                }
                case 'hr': {
                    return this.renderer.hr();
                }
                case 'heading': {
                    return this.renderer.heading(this.inline.output(this.token.text), this.token.depth, unescape(this.inlineText.output(this.token.text)), this.slugger);
                }
                case 'code': {
                    return this.renderer.code(this.token.text, this.token.lang, this.token.escaped);
                }
                case 'table': {
                    var header = '', body = '', i, row, cell, j;
                    // header
                    cell = '';
                    for (i = 0; i < this.token.header.length; i++) {
                        cell += this.renderer.tablecell(this.inline.output(this.token.header[i]), { header: true, align: this.token.align[i] });
                    }
                    header += this.renderer.tablerow(cell);
                    for (i = 0; i < this.token.cells.length; i++) {
                        row = this.token.cells[i];
                        cell = '';
                        for (j = 0; j < row.length; j++) {
                            cell += this.renderer.tablecell(this.inline.output(row[j]), { header: false, align: this.token.align[j] });
                        }
                        body += this.renderer.tablerow(cell);
                    }
                    return this.renderer.table(header, body);
                }
                case 'blockquote_start': {
                    body = '';
                    while (this.next().type !== 'blockquote_end') {
                        body += this.tok();
                    }
                    return this.renderer.blockquote(body);
                }
                case 'list_start': {
                    body = '';
                    var ordered = this.token.ordered, start = this.token.start;
                    while (this.next().type !== 'list_end') {
                        body += this.tok();
                    }
                    return this.renderer.list(body, ordered, start);
                }
                case 'list_item_start': {
                    body = '';
                    var loose = this.token.loose;
                    var checked = this.token.checked;
                    var task = this.token.task;
                    if (this.token.task) {
                        body += this.renderer.checkbox(checked);
                    }
                    while (this.next().type !== 'list_item_end') {
                        body += !loose && this.token.type === 'text'
                            ? this.parseText()
                            : this.tok();
                    }
                    return this.renderer.listitem(body, task, checked);
                }
                case 'html': {
                    // TODO parse inline content if parameter markdown=1
                    return this.renderer.html(this.token.text);
                }
                case 'paragraph': {
                    return this.renderer.paragraph(this.inline.output(this.token.text));
                }
                case 'text': {
                    return this.renderer.paragraph(this.parseText());
                }
                default: {
                    var errMsg = 'Token with "' + this.token.type + '" type was not found.';
                    if (this.options.silent) {
                        console.log(errMsg);
                    }
                    else {
                        throw new Error(errMsg);
                    }
                }
            }
        };
        /**
         * Slugger generates header id
         */
        function Slugger() {
            this.seen = {};
        }
        /**
         * Convert string to unique id
         */
        Slugger.prototype.slug = function (value) {
            var slug = value
                .toLowerCase()
                .trim()
                .replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, '')
                .replace(/\s/g, '-');
            if (this.seen.hasOwnProperty(slug)) {
                var originalSlug = slug;
                do {
                    this.seen[originalSlug]++;
                    slug = originalSlug + '-' + this.seen[originalSlug];
                } while (this.seen.hasOwnProperty(slug));
            }
            this.seen[slug] = 0;
            return slug;
        };
        /**
         * Helpers
         */
        function escape(html, encode) {
            if (encode) {
                if (escape.escapeTest.test(html)) {
                    return html.replace(escape.escapeReplace, function (ch) { return escape.replacements[ch]; });
                }
            }
            else {
                if (escape.escapeTestNoEncode.test(html)) {
                    return html.replace(escape.escapeReplaceNoEncode, function (ch) { return escape.replacements[ch]; });
                }
            }
            return html;
        }
        escape.escapeTest = /[&<>"']/;
        escape.escapeReplace = /[&<>"']/g;
        escape.replacements = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#39;'
        };
        escape.escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
        escape.escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;
        function unescape(html) {
            // explicitly match decimal, hex, and named HTML entities
            return html.replace(/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig, function (_, n) {
                n = n.toLowerCase();
                if (n === 'colon')
                    return ':';
                if (n.charAt(0) === '#') {
                    return n.charAt(1) === 'x'
                        ? String.fromCharCode(parseInt(n.substring(2), 16))
                        : String.fromCharCode(+n.substring(1));
                }
                return '';
            });
        }
        function edit(regex, opt) {
            regex = regex.source || regex;
            opt = opt || '';
            return {
                replace: function (name, val) {
                    val = val.source || val;
                    val = val.replace(/(^|[^\[])\^/g, '$1');
                    regex = regex.replace(name, val);
                    return this;
                },
                getRegex: function () {
                    return new RegExp(regex, opt);
                }
            };
        }
        function cleanUrl(sanitize, base, href) {
            if (sanitize) {
                try {
                    var prot = decodeURIComponent(unescape(href))
                        .replace(/[^\w:]/g, '')
                        .toLowerCase();
                }
                catch (e) {
                    return null;
                }
                if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {
                    return null;
                }
            }
            if (base && !originIndependentUrl.test(href)) {
                href = resolveUrl(base, href);
            }
            try {
                href = encodeURI(href).replace(/%25/g, '%');
            }
            catch (e) {
                return null;
            }
            return href;
        }
        function resolveUrl(base, href) {
            if (!baseUrls[' ' + base]) {
                // we can ignore everything in base after the last slash of its path component,
                // but we might need to add _that_
                // https://tools.ietf.org/html/rfc3986#section-3
                if (/^[^:]+:\/*[^/]*$/.test(base)) {
                    baseUrls[' ' + base] = base + '/';
                }
                else {
                    baseUrls[' ' + base] = rtrim(base, '/', true);
                }
            }
            base = baseUrls[' ' + base];
            if (href.slice(0, 2) === '//') {
                return base.replace(/:[\s\S]*/, ':') + href;
            }
            else if (href.charAt(0) === '/') {
                return base.replace(/(:\/*[^/]*)[\s\S]*/, '$1') + href;
            }
            else {
                return base + href;
            }
        }
        var baseUrls = {};
        var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
        function noop() { }
        noop.exec = noop;
        function merge(obj) {
            var i = 1, target, key;
            for (; i < arguments.length; i++) {
                target = arguments[i];
                for (key in target) {
                    if (Object.prototype.hasOwnProperty.call(target, key)) {
                        obj[key] = target[key];
                    }
                }
            }
            return obj;
        }
        function splitCells(tableRow, count) {
            // ensure that every cell-delimiting pipe has a space
            // before it to distinguish it from an escaped pipe
            var row = tableRow.replace(/\|/g, function (match, offset, str) {
                var escaped = false, curr = offset;
                while (--curr >= 0 && str[curr] === '\\')
                    escaped = !escaped;
                if (escaped) {
                    // odd number of slashes means | is escaped
                    // so we leave it alone
                    return '|';
                }
                else {
                    // add space before unescaped |
                    return ' |';
                }
            }), cells = row.split(/ \|/), i = 0;
            if (cells.length > count) {
                cells.splice(count);
            }
            else {
                while (cells.length < count)
                    cells.push('');
            }
            for (; i < cells.length; i++) {
                // leading or trailing whitespace is ignored per the gfm spec
                cells[i] = cells[i].trim().replace(/\\\|/g, '|');
            }
            return cells;
        }
        // Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').
        // /c*$/ is vulnerable to REDOS.
        // invert: Remove suffix of non-c chars instead. Default falsey.
        function rtrim(str, c, invert) {
            if (str.length === 0) {
                return '';
            }
            // Length of suffix matching the invert condition.
            var suffLen = 0;
            // Step left until we fail to match the invert condition.
            while (suffLen < str.length) {
                var currChar = str.charAt(str.length - suffLen - 1);
                if (currChar === c && !invert) {
                    suffLen++;
                }
                else if (currChar !== c && invert) {
                    suffLen++;
                }
                else {
                    break;
                }
            }
            return str.substr(0, str.length - suffLen);
        }
        function findClosingBracket(str, b) {
            if (str.indexOf(b[1]) === -1) {
                return -1;
            }
            var level = 0;
            for (var i = 0; i < str.length; i++) {
                if (str[i] === '\\') {
                    i++;
                }
                else if (str[i] === b[0]) {
                    level++;
                }
                else if (str[i] === b[1]) {
                    level--;
                    if (level < 0) {
                        return i;
                    }
                }
            }
            return -1;
        }
        function checkSanitizeDeprecation(opt) {
            if (opt && opt.sanitize && !opt.silent) {
                console.warn('marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options');
            }
        }
        /**
         * Marked
         */
        function marked(src, opt, callback) {
            // throw error in case of non string input
            if (typeof src === 'undefined' || src === null) {
                throw new Error('marked(): input parameter is undefined or null');
            }
            if (typeof src !== 'string') {
                throw new Error('marked(): input parameter is of type '
                    + Object.prototype.toString.call(src) + ', string expected');
            }
            if (callback || typeof opt === 'function') {
                if (!callback) {
                    callback = opt;
                    opt = null;
                }
                opt = merge({}, marked.defaults, opt || {});
                checkSanitizeDeprecation(opt);
                var highlight = opt.highlight, tokens, pending, i = 0;
                try {
                    tokens = Lexer.lex(src, opt);
                }
                catch (e) {
                    return callback(e);
                }
                pending = tokens.length;
                var done = function (err) {
                    if (err) {
                        opt.highlight = highlight;
                        return callback(err);
                    }
                    var out;
                    try {
                        out = Parser.parse(tokens, opt);
                    }
                    catch (e) {
                        err = e;
                    }
                    opt.highlight = highlight;
                    return err
                        ? callback(err)
                        : callback(null, out);
                };
                if (!highlight || highlight.length < 3) {
                    return done();
                }
                delete opt.highlight;
                if (!pending)
                    return done();
                for (; i < tokens.length; i++) {
                    (function (token) {
                        if (token.type !== 'code') {
                            return --pending || done();
                        }
                        return highlight(token.text, token.lang, function (err, code) {
                            if (err)
                                return done(err);
                            if (code == null || code === token.text) {
                                return --pending || done();
                            }
                            token.text = code;
                            token.escaped = true;
                            --pending || done();
                        });
                    })(tokens[i]);
                }
                return;
            }
            try {
                if (opt)
                    opt = merge({}, marked.defaults, opt);
                checkSanitizeDeprecation(opt);
                return Parser.parse(Lexer.lex(src, opt), opt);
            }
            catch (e) {
                e.message += '\nPlease report this to https://github.com/markedjs/marked.';
                if ((opt || marked.defaults).silent) {
                    return '<p>An error occurred:</p><pre>'
                        + escape(e.message + '', true)
                        + '</pre>';
                }
                throw e;
            }
        }
        /**
         * Options
         */
        marked.options =
            marked.setOptions = function (opt) {
                merge(marked.defaults, opt);
                return marked;
            };
        marked.getDefaults = function () {
            return {
                baseUrl: null,
                breaks: false,
                gfm: true,
                headerIds: true,
                headerPrefix: '',
                highlight: null,
                langPrefix: 'language-',
                mangle: true,
                pedantic: false,
                renderer: new Renderer(),
                sanitize: false,
                sanitizer: null,
                silent: false,
                smartLists: false,
                smartypants: false,
                xhtml: false
            };
        };
        marked.defaults = marked.getDefaults();
        /**
         * Expose
         */
        marked.Parser = Parser;
        marked.parser = Parser.parse;
        marked.Renderer = Renderer;
        marked.TextRenderer = TextRenderer;
        marked.Lexer = Lexer;
        marked.lexer = Lexer.lex;
        marked.InlineLexer = InlineLexer;
        marked.inlineLexer = InlineLexer.output;
        marked.Slugger = Slugger;
        marked.parse = marked;
        {
            module.exports = marked;
        }
    })();
});
/**
 * Have the renderer display code blocks as `<chef-snippet>` tags instead
 * of `<pre>` tags to keep styling of code blocks consistent.
 */
var renderer = Object.assign(new marked.Renderer(), {
    code: function (code, lang) {
        return "<chef-snippet code=\"" + code.replace(/"/g, '&quot;') + "\" lang=\"" + lang + "\"></chef-snippet>";
    }
});
/**
 * @description
 * The `<chef-markdown>` atom is used to parse and display markdown text.
 *
 * @example
 * <chef-markdown text="# Heading with a [link](#to-nothing)"></chef-markdown>
 *
 * @example
 * <textarea id='md-editor' placeholder='Type some markdown...'></textarea>
 * <chef-markdown id='md-display'></chef-markdown>
 *
 * <style>
 *  #md-editor { width: 100%; min-height: 10em; }
 * </style>
 *
 * <script>
 *   const editor = document.getElementById('md-editor');
 *   const display = document.getElementById('md-display');
 *   editor.addEventListener('input', e => display.text = e.target.value);
 * </script>
 */
var ChefMarkdown = /** @class */ (function () {
    function ChefMarkdown(hostRef) {
        registerInstance(this, hostRef);
        /**
         * The markdown text to be parsed.
         */
        this.text = '';
    }
    ChefMarkdown.prototype.render = function () {
        var parsed = this.parse(this.text);
        return (h("div", { innerHTML: parsed }));
    };
    ChefMarkdown.prototype.parse = function (text) {
        return marked.parse(text, { renderer: renderer });
    };
    Object.defineProperty(ChefMarkdown, "style", {
        get: function () { return "chef-markdown{display:block}"; },
        enumerable: true,
        configurable: true
    });
    return ChefMarkdown;
}());
var prism = createCommonjsModule(function (module) {
    /* **********************************************
         Begin prism-core.js
    ********************************************** */
    /// <reference lib="WebWorker"/>
    var _self = (typeof window !== 'undefined')
        ? window // if in browser
        : ((typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)
            ? self // if in worker
            : {} // if in node js
        );
    /**
     * Prism: Lightweight, robust, elegant syntax highlighting
     *
     * @license MIT <https://opensource.org/licenses/MIT>
     * @author Lea Verou <https://lea.verou.me>
     * @namespace
     * @public
     */
    var Prism = (function (_self) {
        // Private helper vars
        var lang = /\blang(?:uage)?-([\w-]+)\b/i;
        var uniqueId = 0;
        // The grammar object for plaintext
        var plainTextGrammar = {};
        var _ = {
            /**
             * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
             * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
             * additional languages or plugins yourself.
             *
             * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
             *
             * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
             * empty Prism object into the global scope before loading the Prism script like this:
             *
             * ```js
             * window.Prism = window.Prism || {};
             * Prism.manual = true;
             * // add a new <script> to load Prism's script
             * ```
             *
             * @default false
             * @type {boolean}
             * @memberof Prism
             * @public
             */
            manual: _self.Prism && _self.Prism.manual,
            disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,
            /**
             * A namespace for utility methods.
             *
             * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
             * change or disappear at any time.
             *
             * @namespace
             * @memberof Prism
             */
            util: {
                encode: function encode(tokens) {
                    if (tokens instanceof Token) {
                        return new Token(tokens.type, encode(tokens.content), tokens.alias);
                    }
                    else if (Array.isArray(tokens)) {
                        return tokens.map(encode);
                    }
                    else {
                        return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
                    }
                },
                /**
                 * Returns the name of the type of the given value.
                 *
                 * @param {any} o
                 * @returns {string}
                 * @example
                 * type(null)      === 'Null'
                 * type(undefined) === 'Undefined'
                 * type(123)       === 'Number'
                 * type('foo')     === 'String'
                 * type(true)      === 'Boolean'
                 * type([1, 2])    === 'Array'
                 * type({})        === 'Object'
                 * type(String)    === 'Function'
                 * type(/abc+/)    === 'RegExp'
                 */
                type: function (o) {
                    return Object.prototype.toString.call(o).slice(8, -1);
                },
                /**
                 * Returns a unique number for the given object. Later calls will still return the same number.
                 *
                 * @param {Object} obj
                 * @returns {number}
                 */
                objId: function (obj) {
                    if (!obj['__id']) {
                        Object.defineProperty(obj, '__id', { value: ++uniqueId });
                    }
                    return obj['__id'];
                },
                /**
                 * Creates a deep clone of the given object.
                 *
                 * The main intended use of this function is to clone language definitions.
                 *
                 * @param {T} o
                 * @param {Record<number, any>} [visited]
                 * @returns {T}
                 * @template T
                 */
                clone: function deepClone(o, visited) {
                    visited = visited || {};
                    var clone;
                    var id;
                    switch (_.util.type(o)) {
                        case 'Object':
                            id = _.util.objId(o);
                            if (visited[id]) {
                                return visited[id];
                            }
                            clone = /** @type {Record<string, any>} */ ({});
                            visited[id] = clone;
                            for (var key in o) {
                                if (o.hasOwnProperty(key)) {
                                    clone[key] = deepClone(o[key], visited);
                                }
                            }
                            return /** @type {any} */ (clone);
                        case 'Array':
                            id = _.util.objId(o);
                            if (visited[id]) {
                                return visited[id];
                            }
                            clone = [];
                            visited[id] = clone;
                            ( /** @type {Array} */( /** @type {any} */(o))).forEach(function (v, i) {
                                clone[i] = deepClone(v, visited);
                            });
                            return /** @type {any} */ (clone);
                        default:
                            return o;
                    }
                },
                /**
                 * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
                 *
                 * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
                 *
                 * @param {Element} element
                 * @returns {string}
                 */
                getLanguage: function (element) {
                    while (element && !lang.test(element.className)) {
                        element = element.parentElement;
                    }
                    if (element) {
                        return (element.className.match(lang) || [, 'none'])[1].toLowerCase();
                    }
                    return 'none';
                },
                /**
                 * Returns the script element that is currently executing.
                 *
                 * This does __not__ work for line script element.
                 *
                 * @returns {HTMLScriptElement | null}
                 */
                currentScript: function () {
                    if (typeof document === 'undefined') {
                        return null;
                    }
                    if ('currentScript' in document && 1 < 2 /* hack to trip TS' flow analysis */) {
                        return /** @type {any} */ (document.currentScript);
                    }
                    // IE11 workaround
                    // we'll get the src of the current script by parsing IE11's error stack trace
                    // this will not work for inline scripts
                    try {
                        throw new Error();
                    }
                    catch (err) {
                        // Get file src url from stack. Specifically works with the format of stack traces in IE.
                        // A stack will look like this:
                        //
                        // Error
                        //    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)
                        //    at Global code (http://localhost/components/prism-core.js:606:1)
                        var src = (/at [^(\r\n]*\((.*):.+:.+\)$/i.exec(err.stack) || [])[1];
                        if (src) {
                            var scripts = document.getElementsByTagName('script');
                            for (var i in scripts) {
                                if (scripts[i].src == src) {
                                    return scripts[i];
                                }
                            }
                        }
                        return null;
                    }
                },
                /**
                 * Returns whether a given class is active for `element`.
                 *
                 * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
                 * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
                 * given class is just the given class with a `no-` prefix.
                 *
                 * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
                 * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
                 * ancestors have the given class or the negated version of it, then the default activation will be returned.
                 *
                 * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
                 * version of it, the class is considered active.
                 *
                 * @param {Element} element
                 * @param {string} className
                 * @param {boolean} [defaultActivation=false]
                 * @returns {boolean}
                 */
                isActive: function (element, className, defaultActivation) {
                    var no = 'no-' + className;
                    while (element) {
                        var classList = element.classList;
                        if (classList.contains(className)) {
                            return true;
                        }
                        if (classList.contains(no)) {
                            return false;
                        }
                        element = element.parentElement;
                    }
                    return !!defaultActivation;
                }
            },
            /**
             * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
             *
             * @namespace
             * @memberof Prism
             * @public
             */
            languages: {
                /**
                 * The grammar for plain, unformatted text.
                 */
                plain: plainTextGrammar,
                plaintext: plainTextGrammar,
                text: plainTextGrammar,
                txt: plainTextGrammar,
                /**
                 * Creates a deep copy of the language with the given id and appends the given tokens.
                 *
                 * If a token in `redef` also appears in the copied language, then the existing token in the copied language
                 * will be overwritten at its original position.
                 *
                 * ## Best practices
                 *
                 * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
                 * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
                 * understand the language definition because, normally, the order of tokens matters in Prism grammars.
                 *
                 * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
                 * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
                 *
                 * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
                 * @param {Grammar} redef The new tokens to append.
                 * @returns {Grammar} The new language created.
                 * @public
                 * @example
                 * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
                 *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
                 *     // at its original position
                 *     'comment': { ... },
                 *     // CSS doesn't have a 'color' token, so this token will be appended
                 *     'color': /\b(?:red|green|blue)\b/
                 * });
                 */
                extend: function (id, redef) {
                    var lang = _.util.clone(_.languages[id]);
                    for (var key in redef) {
                        lang[key] = redef[key];
                    }
                    return lang;
                },
                /**
                 * Inserts tokens _before_ another token in a language definition or any other grammar.
                 *
                 * ## Usage
                 *
                 * This helper method makes it easy to modify existing languages. For example, the CSS language definition
                 * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
                 * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
                 * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
                 * this:
                 *
                 * ```js
                 * Prism.languages.markup.style = {
                 *     // token
                 * };
                 * ```
                 *
                 * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
                 * before existing tokens. For the CSS example above, you would use it like this:
                 *
                 * ```js
                 * Prism.languages.insertBefore('markup', 'cdata', {
                 *     'style': {
                 *         // token
                 *     }
                 * });
                 * ```
                 *
                 * ## Special cases
                 *
                 * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
                 * will be ignored.
                 *
                 * This behavior can be used to insert tokens after `before`:
                 *
                 * ```js
                 * Prism.languages.insertBefore('markup', 'comment', {
                 *     'comment': Prism.languages.markup.comment,
                 *     // tokens after 'comment'
                 * });
                 * ```
                 *
                 * ## Limitations
                 *
                 * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
                 * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
                 * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
                 * deleting properties which is necessary to insert at arbitrary positions.
                 *
                 * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
                 * Instead, it will create a new object and replace all references to the target object with the new one. This
                 * can be done without temporarily deleting properties, so the iteration order is well-defined.
                 *
                 * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
                 * you hold the target object in a variable, then the value of the variable will not change.
                 *
                 * ```js
                 * var oldMarkup = Prism.languages.markup;
                 * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
                 *
                 * assert(oldMarkup !== Prism.languages.markup);
                 * assert(newMarkup === Prism.languages.markup);
                 * ```
                 *
                 * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
                 * object to be modified.
                 * @param {string} before The key to insert before.
                 * @param {Grammar} insert An object containing the key-value pairs to be inserted.
                 * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
                 * object to be modified.
                 *
                 * Defaults to `Prism.languages`.
                 * @returns {Grammar} The new grammar object.
                 * @public
                 */
                insertBefore: function (inside, before, insert, root) {
                    root = root || /** @type {any} */ (_.languages);
                    var grammar = root[inside];
                    /** @type {Grammar} */
                    var ret = {};
                    for (var token in grammar) {
                        if (grammar.hasOwnProperty(token)) {
                            if (token == before) {
                                for (var newToken in insert) {
                                    if (insert.hasOwnProperty(newToken)) {
                                        ret[newToken] = insert[newToken];
                                    }
                                }
                            }
                            // Do not insert token which also occur in insert. See #1525
                            if (!insert.hasOwnProperty(token)) {
                                ret[token] = grammar[token];
                            }
                        }
                    }
                    var old = root[inside];
                    root[inside] = ret;
                    // Update references in other language definitions
                    _.languages.DFS(_.languages, function (key, value) {
                        if (value === old && key != inside) {
                            this[key] = ret;
                        }
                    });
                    return ret;
                },
                // Traverse a language definition with Depth First Search
                DFS: function DFS(o, callback, type, visited) {
                    visited = visited || {};
                    var objId = _.util.objId;
                    for (var i in o) {
                        if (o.hasOwnProperty(i)) {
                            callback.call(o, i, o[i], type || i);
                            var property = o[i];
                            var propertyType = _.util.type(property);
                            if (propertyType === 'Object' && !visited[objId(property)]) {
                                visited[objId(property)] = true;
                                DFS(property, callback, null, visited);
                            }
                            else if (propertyType === 'Array' && !visited[objId(property)]) {
                                visited[objId(property)] = true;
                                DFS(property, callback, i, visited);
                            }
                        }
                    }
                }
            },
            plugins: {},
            /**
             * This is the most high-level function in Prism’s API.
             * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
             * each one of them.
             *
             * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
             *
             * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
             * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
             * @memberof Prism
             * @public
             */
            highlightAll: function (async, callback) {
                _.highlightAllUnder(document, async, callback);
            },
            /**
             * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
             * {@link Prism.highlightElement} on each one of them.
             *
             * The following hooks will be run:
             * 1. `before-highlightall`
             * 2. `before-all-elements-highlight`
             * 3. All hooks of {@link Prism.highlightElement} for each element.
             *
             * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
             * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
             * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
             * @memberof Prism
             * @public
             */
            highlightAllUnder: function (container, async, callback) {
                var env = {
                    callback: callback,
                    container: container,
                    selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
                };
                _.hooks.run('before-highlightall', env);
                env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));
                _.hooks.run('before-all-elements-highlight', env);
                for (var i = 0, element; (element = env.elements[i++]);) {
                    _.highlightElement(element, async === true, env.callback);
                }
            },
            /**
             * Highlights the code inside a single element.
             *
             * The following hooks will be run:
             * 1. `before-sanity-check`
             * 2. `before-highlight`
             * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
             * 4. `before-insert`
             * 5. `after-highlight`
             * 6. `complete`
             *
             * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
             * the element's language.
             *
             * @param {Element} element The element containing the code.
             * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
             * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
             * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
             * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
             *
             * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
             * asynchronous highlighting to work. You can build your own bundle on the
             * [Download page](https://prismjs.com/download.html).
             * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
             * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
             * @memberof Prism
             * @public
             */
            highlightElement: function (element, async, callback) {
                // Find language
                var language = _.util.getLanguage(element);
                var grammar = _.languages[language];
                // Set language on the element, if not present
                element.className = element.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;
                // Set language on the parent, for styling
                var parent = element.parentElement;
                if (parent && parent.nodeName.toLowerCase() === 'pre') {
                    parent.className = parent.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;
                }
                var code = element.textContent;
                var env = {
                    element: element,
                    language: language,
                    grammar: grammar,
                    code: code
                };
                function insertHighlightedCode(highlightedCode) {
                    env.highlightedCode = highlightedCode;
                    _.hooks.run('before-insert', env);
                    env.element.innerHTML = env.highlightedCode;
                    _.hooks.run('after-highlight', env);
                    _.hooks.run('complete', env);
                    callback && callback.call(env.element);
                }
                _.hooks.run('before-sanity-check', env);
                // plugins may change/add the parent/element
                parent = env.element.parentElement;
                if (parent && parent.nodeName.toLowerCase() === 'pre' && !parent.hasAttribute('tabindex')) {
                    parent.setAttribute('tabindex', '0');
                }
                if (!env.code) {
                    _.hooks.run('complete', env);
                    callback && callback.call(env.element);
                    return;
                }
                _.hooks.run('before-highlight', env);
                if (!env.grammar) {
                    insertHighlightedCode(_.util.encode(env.code));
                    return;
                }
                if (async && _self.Worker) {
                    var worker = new Worker(_.filename);
                    worker.onmessage = function (evt) {
                        insertHighlightedCode(evt.data);
                    };
                    worker.postMessage(JSON.stringify({
                        language: env.language,
                        code: env.code,
                        immediateClose: true
                    }));
                }
                else {
                    insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
                }
            },
            /**
             * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
             * and the language definitions to use, and returns a string with the HTML produced.
             *
             * The following hooks will be run:
             * 1. `before-tokenize`
             * 2. `after-tokenize`
             * 3. `wrap`: On each {@link Token}.
             *
             * @param {string} text A string with the code to be highlighted.
             * @param {Grammar} grammar An object containing the tokens to use.
             *
             * Usually a language definition like `Prism.languages.markup`.
             * @param {string} language The name of the language definition passed to `grammar`.
             * @returns {string} The highlighted HTML.
             * @memberof Prism
             * @public
             * @example
             * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
             */
            highlight: function (text, grammar, language) {
                var env = {
                    code: text,
                    grammar: grammar,
                    language: language
                };
                _.hooks.run('before-tokenize', env);
                env.tokens = _.tokenize(env.code, env.grammar);
                _.hooks.run('after-tokenize', env);
                return Token.stringify(_.util.encode(env.tokens), env.language);
            },
            /**
             * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
             * and the language definitions to use, and returns an array with the tokenized code.
             *
             * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
             *
             * This method could be useful in other contexts as well, as a very crude parser.
             *
             * @param {string} text A string with the code to be highlighted.
             * @param {Grammar} grammar An object containing the tokens to use.
             *
             * Usually a language definition like `Prism.languages.markup`.
             * @returns {TokenStream} An array of strings and tokens, a token stream.
             * @memberof Prism
             * @public
             * @example
             * let code = `var foo = 0;`;
             * let tokens = Prism.tokenize(code, Prism.languages.javascript);
             * tokens.forEach(token => {
             *     if (token instanceof Prism.Token && token.type === 'number') {
             *         console.log(`Found numeric literal: ${token.content}`);
             *     }
             * });
             */
            tokenize: function (text, grammar) {
                var rest = grammar.rest;
                if (rest) {
                    for (var token in rest) {
                        grammar[token] = rest[token];
                    }
                    delete grammar.rest;
                }
                var tokenList = new LinkedList();
                addAfter(tokenList, tokenList.head, text);
                matchGrammar(text, tokenList, grammar, tokenList.head, 0);
                return toArray(tokenList);
            },
            /**
             * @namespace
             * @memberof Prism
             * @public
             */
            hooks: {
                all: {},
                /**
                 * Adds the given callback to the list of callbacks for the given hook.
                 *
                 * The callback will be invoked when the hook it is registered for is run.
                 * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
                 *
                 * One callback function can be registered to multiple hooks and the same hook multiple times.
                 *
                 * @param {string} name The name of the hook.
                 * @param {HookCallback} callback The callback function which is given environment variables.
                 * @public
                 */
                add: function (name, callback) {
                    var hooks = _.hooks.all;
                    hooks[name] = hooks[name] || [];
                    hooks[name].push(callback);
                },
                /**
                 * Runs a hook invoking all registered callbacks with the given environment variables.
                 *
                 * Callbacks will be invoked synchronously and in the order in which they were registered.
                 *
                 * @param {string} name The name of the hook.
                 * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
                 * @public
                 */
                run: function (name, env) {
                    var callbacks = _.hooks.all[name];
                    if (!callbacks || !callbacks.length) {
                        return;
                    }
                    for (var i = 0, callback; (callback = callbacks[i++]);) {
                        callback(env);
                    }
                }
            },
            Token: Token
        };
        _self.Prism = _;
        // Typescript note:
        // The following can be used to import the Token type in JSDoc:
        //
        //   @typedef {InstanceType<import("./prism-core")["Token"]>} Token
        /**
         * Creates a new token.
         *
         * @param {string} type See {@link Token#type type}
         * @param {string | TokenStream} content See {@link Token#content content}
         * @param {string|string[]} [alias] The alias(es) of the token.
         * @param {string} [matchedStr=""] A copy of the full string this token was created from.
         * @class
         * @global
         * @public
         */
        function Token(type, content, alias, matchedStr) {
            /**
             * The type of the token.
             *
             * This is usually the key of a pattern in a {@link Grammar}.
             *
             * @type {string}
             * @see GrammarToken
             * @public
             */
            this.type = type;
            /**
             * The strings or tokens contained by this token.
             *
             * This will be a token stream if the pattern matched also defined an `inside` grammar.
             *
             * @type {string | TokenStream}
             * @public
             */
            this.content = content;
            /**
             * The alias(es) of the token.
             *
             * @type {string|string[]}
             * @see GrammarToken
             * @public
             */
            this.alias = alias;
            // Copy of the full string this token was created from
            this.length = (matchedStr || '').length | 0;
        }
        /**
         * A token stream is an array of strings and {@link Token Token} objects.
         *
         * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process
         * them.
         *
         * 1. No adjacent strings.
         * 2. No empty strings.
         *
         *    The only exception here is the token stream that only contains the empty string and nothing else.
         *
         * @typedef {Array<string | Token>} TokenStream
         * @global
         * @public
         */
        /**
         * Converts the given token or token stream to an HTML representation.
         *
         * The following hooks will be run:
         * 1. `wrap`: On each {@link Token}.
         *
         * @param {string | Token | TokenStream} o The token or token stream to be converted.
         * @param {string} language The name of current language.
         * @returns {string} The HTML representation of the token or token stream.
         * @memberof Token
         * @static
         */
        Token.stringify = function stringify(o, language) {
            if (typeof o == 'string') {
                return o;
            }
            if (Array.isArray(o)) {
                var s = '';
                o.forEach(function (e) {
                    s += stringify(e, language);
                });
                return s;
            }
            var env = {
                type: o.type,
                content: stringify(o.content, language),
                tag: 'span',
                classes: ['token', o.type],
                attributes: {},
                language: language
            };
            var aliases = o.alias;
            if (aliases) {
                if (Array.isArray(aliases)) {
                    Array.prototype.push.apply(env.classes, aliases);
                }
                else {
                    env.classes.push(aliases);
                }
            }
            _.hooks.run('wrap', env);
            var attributes = '';
            for (var name in env.attributes) {
                attributes += ' ' + name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
            }
            return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + attributes + '>' + env.content + '</' + env.tag + '>';
        };
        /**
         * @param {RegExp} pattern
         * @param {number} pos
         * @param {string} text
         * @param {boolean} lookbehind
         * @returns {RegExpExecArray | null}
         */
        function matchPattern(pattern, pos, text, lookbehind) {
            pattern.lastIndex = pos;
            var match = pattern.exec(text);
            if (match && lookbehind && match[1]) {
                // change the match to remove the text matched by the Prism lookbehind group
                var lookbehindLength = match[1].length;
                match.index += lookbehindLength;
                match[0] = match[0].slice(lookbehindLength);
            }
            return match;
        }
        /**
         * @param {string} text
         * @param {LinkedList<string | Token>} tokenList
         * @param {any} grammar
         * @param {LinkedListNode<string | Token>} startNode
         * @param {number} startPos
         * @param {RematchOptions} [rematch]
         * @returns {void}
         * @private
         *
         * @typedef RematchOptions
         * @property {string} cause
         * @property {number} reach
         */
        function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
            for (var token in grammar) {
                if (!grammar.hasOwnProperty(token) || !grammar[token]) {
                    continue;
                }
                var patterns = grammar[token];
                patterns = Array.isArray(patterns) ? patterns : [patterns];
                for (var j = 0; j < patterns.length; ++j) {
                    if (rematch && rematch.cause == token + ',' + j) {
                        return;
                    }
                    var patternObj = patterns[j];
                    var inside = patternObj.inside;
                    var lookbehind = !!patternObj.lookbehind;
                    var greedy = !!patternObj.greedy;
                    var alias = patternObj.alias;
                    if (greedy && !patternObj.pattern.global) {
                        // Without the global flag, lastIndex won't work
                        var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
                        patternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g');
                    }
                    /** @type {RegExp} */
                    var pattern = patternObj.pattern || patternObj;
                    for ( // iterate the token list and keep track of the current token/string position
                    var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
                        if (rematch && pos >= rematch.reach) {
                            break;
                        }
                        var str = currentNode.value;
                        if (tokenList.length > text.length) {
                            // Something went terribly wrong, ABORT, ABORT!
                            return;
                        }
                        if (str instanceof Token) {
                            continue;
                        }
                        var removeCount = 1; // this is the to parameter of removeBetween
                        var match;
                        if (greedy) {
                            match = matchPattern(pattern, pos, text, lookbehind);
                            if (!match) {
                                break;
                            }
                            var from = match.index;
                            var to = match.index + match[0].length;
                            var p = pos;
                            // find the node that contains the match
                            p += currentNode.value.length;
                            while (from >= p) {
                                currentNode = currentNode.next;
                                p += currentNode.value.length;
                            }
                            // adjust pos (and p)
                            p -= currentNode.value.length;
                            pos = p;
                            // the current node is a Token, then the match starts inside another Token, which is invalid
                            if (currentNode.value instanceof Token) {
                                continue;
                            }
                            // find the last node which is affected by this match
                            for (var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value === 'string'); k = k.next) {
                                removeCount++;
                                p += k.value.length;
                            }
                            removeCount--;
                            // replace with the new match
                            str = text.slice(pos, p);
                            match.index -= pos;
                        }
                        else {
                            match = matchPattern(pattern, 0, str, lookbehind);
                            if (!match) {
                                continue;
                            }
                        }
                        // eslint-disable-next-line no-redeclare
                        var from = match.index;
                        var matchStr = match[0];
                        var before = str.slice(0, from);
                        var after = str.slice(from + matchStr.length);
                        var reach = pos + str.length;
                        if (rematch && reach > rematch.reach) {
                            rematch.reach = reach;
                        }
                        var removeFrom = currentNode.prev;
                        if (before) {
                            removeFrom = addAfter(tokenList, removeFrom, before);
                            pos += before.length;
                        }
                        removeRange(tokenList, removeFrom, removeCount);
                        var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
                        currentNode = addAfter(tokenList, removeFrom, wrapped);
                        if (after) {
                            addAfter(tokenList, currentNode, after);
                        }
                        if (removeCount > 1) {
                            // at least one Token object was removed, so we have to do some rematching
                            // this can only happen if the current pattern is greedy
                            /** @type {RematchOptions} */
                            var nestedRematch = {
                                cause: token + ',' + j,
                                reach: reach
                            };
                            matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);
                            // the reach might have been extended because of the rematching
                            if (rematch && nestedRematch.reach > rematch.reach) {
                                rematch.reach = nestedRematch.reach;
                            }
                        }
                    }
                }
            }
        }
        /**
         * @typedef LinkedListNode
         * @property {T} value
         * @property {LinkedListNode<T> | null} prev The previous node.
         * @property {LinkedListNode<T> | null} next The next node.
         * @template T
         * @private
         */
        /**
         * @template T
         * @private
         */
        function LinkedList() {
            /** @type {LinkedListNode<T>} */
            var head = { value: null, prev: null, next: null };
            /** @type {LinkedListNode<T>} */
            var tail = { value: null, prev: head, next: null };
            head.next = tail;
            /** @type {LinkedListNode<T>} */
            this.head = head;
            /** @type {LinkedListNode<T>} */
            this.tail = tail;
            this.length = 0;
        }
        /**
         * Adds a new node with the given value to the list.
         *
         * @param {LinkedList<T>} list
         * @param {LinkedListNode<T>} node
         * @param {T} value
         * @returns {LinkedListNode<T>} The added node.
         * @template T
         */
        function addAfter(list, node, value) {
            // assumes that node != list.tail && values.length >= 0
            var next = node.next;
            var newNode = { value: value, prev: node, next: next };
            node.next = newNode;
            next.prev = newNode;
            list.length++;
            return newNode;
        }
        /**
         * Removes `count` nodes after the given node. The given node will not be removed.
         *
         * @param {LinkedList<T>} list
         * @param {LinkedListNode<T>} node
         * @param {number} count
         * @template T
         */
        function removeRange(list, node, count) {
            var next = node.next;
            for (var i = 0; i < count && next !== list.tail; i++) {
                next = next.next;
            }
            node.next = next;
            next.prev = node;
            list.length -= i;
        }
        /**
         * @param {LinkedList<T>} list
         * @returns {T[]}
         * @template T
         */
        function toArray(list) {
            var array = [];
            var node = list.head.next;
            while (node !== list.tail) {
                array.push(node.value);
                node = node.next;
            }
            return array;
        }
        if (!_self.document) {
            if (!_self.addEventListener) {
                // in Node.js
                return _;
            }
            if (!_.disableWorkerMessageHandler) {
                // In worker
                _self.addEventListener('message', function (evt) {
                    var message = JSON.parse(evt.data);
                    var lang = message.language;
                    var code = message.code;
                    var immediateClose = message.immediateClose;
                    _self.postMessage(_.highlight(code, _.languages[lang], lang));
                    if (immediateClose) {
                        _self.close();
                    }
                }, false);
            }
            return _;
        }
        // Get current script and highlight
        var script = _.util.currentScript();
        if (script) {
            _.filename = script.src;
            if (script.hasAttribute('data-manual')) {
                _.manual = true;
            }
        }
        function highlightAutomaticallyCallback() {
            if (!_.manual) {
                _.highlightAll();
            }
        }
        if (!_.manual) {
            // If the document state is "loading", then we'll use DOMContentLoaded.
            // If the document state is "interactive" and the prism.js script is deferred, then we'll also use the
            // DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they
            // might take longer one animation frame to execute which can create a race condition where only some plugins have
            // been loaded when Prism.highlightAll() is executed, depending on how fast resources are loaded.
            // See https://github.com/PrismJS/prism/issues/2102
            var readyState = document.readyState;
            if (readyState === 'loading' || readyState === 'interactive' && script && script.defer) {
                document.addEventListener('DOMContentLoaded', highlightAutomaticallyCallback);
            }
            else {
                if (window.requestAnimationFrame) {
                    window.requestAnimationFrame(highlightAutomaticallyCallback);
                }
                else {
                    window.setTimeout(highlightAutomaticallyCallback, 16);
                }
            }
        }
        return _;
    }(_self));
    if (module.exports) {
        module.exports = Prism;
    }
    // hack for components to work correctly in node.js
    if (typeof commonjsGlobal !== 'undefined') {
        commonjsGlobal.Prism = Prism;
    }
    // some additional documentation/types
    /**
     * The expansion of a simple `RegExp` literal to support additional properties.
     *
     * @typedef GrammarToken
     * @property {RegExp} pattern The regular expression of the token.
     * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)
     * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.
     * @property {boolean} [greedy=false] Whether the token is greedy.
     * @property {string|string[]} [alias] An optional alias or list of aliases.
     * @property {Grammar} [inside] The nested grammar of this token.
     *
     * The `inside` grammar will be used to tokenize the text value of each token of this kind.
     *
     * This can be used to make nested and even recursive language definitions.
     *
     * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into
     * each another.
     * @global
     * @public
     */
    /**
     * @typedef Grammar
     * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}
     * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.
     * @global
     * @public
     */
    /**
     * A function which will invoked after an element was successfully highlighted.
     *
     * @callback HighlightCallback
     * @param {Element} element The element successfully highlighted.
     * @returns {void}
     * @global
     * @public
     */
    /**
     * @callback HookCallback
     * @param {Object<string, any>} env The environment variables of the hook.
     * @returns {void}
     * @global
     * @public
     */
    /* **********************************************
         Begin prism-markup.js
    ********************************************** */
    Prism.languages.markup = {
        'comment': /<!--[\s\S]*?-->/,
        'prolog': /<\?[\s\S]+?\?>/,
        'doctype': {
            // https://www.w3.org/TR/xml/#NT-doctypedecl
            pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
            greedy: true,
            inside: {
                'internal-subset': {
                    pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
                    lookbehind: true,
                    greedy: true,
                    inside: null // see below
                },
                'string': {
                    pattern: /"[^"]*"|'[^']*'/,
                    greedy: true
                },
                'punctuation': /^<!|>$|[[\]]/,
                'doctype-tag': /^DOCTYPE/,
                'name': /[^\s<>'"]+/
            }
        },
        'cdata': /<!\[CDATA\[[\s\S]*?\]\]>/i,
        'tag': {
            pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
            greedy: true,
            inside: {
                'tag': {
                    pattern: /^<\/?[^\s>\/]+/,
                    inside: {
                        'punctuation': /^<\/?/,
                        'namespace': /^[^\s>\/:]+:/
                    }
                },
                'special-attr': [],
                'attr-value': {
                    pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
                    inside: {
                        'punctuation': [
                            {
                                pattern: /^=/,
                                alias: 'attr-equals'
                            },
                            /"|'/
                        ]
                    }
                },
                'punctuation': /\/?>/,
                'attr-name': {
                    pattern: /[^\s>\/]+/,
                    inside: {
                        'namespace': /^[^\s>\/:]+:/
                    }
                }
            }
        },
        'entity': [
            {
                pattern: /&[\da-z]{1,8};/i,
                alias: 'named-entity'
            },
            /&#x?[\da-f]{1,8};/i
        ]
    };
    Prism.languages.markup['tag'].inside['attr-value'].inside['entity'] =
        Prism.languages.markup['entity'];
    Prism.languages.markup['doctype'].inside['internal-subset'].inside = Prism.languages.markup;
    // Plugin to make entity title show the real entity, idea by Roman Komarov
    Prism.hooks.add('wrap', function (env) {
        if (env.type === 'entity') {
            env.attributes['title'] = env.content.replace(/&amp;/, '&');
        }
    });
    Object.defineProperty(Prism.languages.markup.tag, 'addInlined', {
        /**
         * Adds an inlined language to markup.
         *
         * An example of an inlined language is CSS with `<style>` tags.
         *
         * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
         * case insensitive.
         * @param {string} lang The language key.
         * @example
         * addInlined('style', 'css');
         */
        value: function addInlined(tagName, lang) {
            var includedCdataInside = {};
            includedCdataInside['language-' + lang] = {
                pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
                lookbehind: true,
                inside: Prism.languages[lang]
            };
            includedCdataInside['cdata'] = /^<!\[CDATA\[|\]\]>$/i;
            var inside = {
                'included-cdata': {
                    pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
                    inside: includedCdataInside
                }
            };
            inside['language-' + lang] = {
                pattern: /[\s\S]+/,
                inside: Prism.languages[lang]
            };
            var def = {};
            def[tagName] = {
                pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function () { return tagName; }), 'i'),
                lookbehind: true,
                greedy: true,
                inside: inside
            };
            Prism.languages.insertBefore('markup', 'cdata', def);
        }
    });
    Object.defineProperty(Prism.languages.markup.tag, 'addAttribute', {
        /**
         * Adds an pattern to highlight languages embedded in HTML attributes.
         *
         * An example of an inlined language is CSS with `style` attributes.
         *
         * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
         * case insensitive.
         * @param {string} lang The language key.
         * @example
         * addAttribute('style', 'css');
         */
        value: function (attrName, lang) {
            Prism.languages.markup.tag.inside['special-attr'].push({
                pattern: RegExp(/(^|["'\s])/.source + '(?:' + attrName + ')' + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, 'i'),
                lookbehind: true,
                inside: {
                    'attr-name': /^[^\s=]+/,
                    'attr-value': {
                        pattern: /=[\s\S]+/,
                        inside: {
                            'value': {
                                pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                                lookbehind: true,
                                alias: [lang, 'language-' + lang],
                                inside: Prism.languages[lang]
                            },
                            'punctuation': [
                                {
                                    pattern: /^=/,
                                    alias: 'attr-equals'
                                },
                                /"|'/
                            ]
                        }
                    }
                }
            });
        }
    });
    Prism.languages.html = Prism.languages.markup;
    Prism.languages.mathml = Prism.languages.markup;
    Prism.languages.svg = Prism.languages.markup;
    Prism.languages.xml = Prism.languages.extend('markup', {});
    Prism.languages.ssml = Prism.languages.xml;
    Prism.languages.atom = Prism.languages.xml;
    Prism.languages.rss = Prism.languages.xml;
    /* **********************************************
         Begin prism-css.js
    ********************************************** */
    (function (Prism) {
        var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
        Prism.languages.css = {
            'comment': /\/\*[\s\S]*?\*\//,
            'atrule': {
                pattern: /@[\w-](?:[^;{\s]|\s+(?![\s{]))*(?:;|(?=\s*\{))/,
                inside: {
                    'rule': /^@[\w-]+/,
                    'selector-function-argument': {
                        pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
                        lookbehind: true,
                        alias: 'selector'
                    },
                    'keyword': {
                        pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
                        lookbehind: true
                    }
                    // See rest below
                }
            },
            'url': {
                // https://drafts.csswg.org/css-values-3/#urls
                pattern: RegExp('\\burl\\((?:' + string.source + '|' + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ')\\)', 'i'),
                greedy: true,
                inside: {
                    'function': /^url/i,
                    'punctuation': /^\(|\)$/,
                    'string': {
                        pattern: RegExp('^' + string.source + '$'),
                        alias: 'url'
                    }
                }
            },
            'selector': {
                pattern: RegExp('(^|[{}\\s])[^{}\\s](?:[^{};"\'\\s]|\\s+(?![\\s{])|' + string.source + ')*(?=\\s*\\{)'),
                lookbehind: true
            },
            'string': {
                pattern: string,
                greedy: true
            },
            'property': {
                pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
                lookbehind: true
            },
            'important': /!important\b/i,
            'function': {
                pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
                lookbehind: true
            },
            'punctuation': /[(){};:,]/
        };
        Prism.languages.css['atrule'].inside.rest = Prism.languages.css;
        var markup = Prism.languages.markup;
        if (markup) {
            markup.tag.addInlined('style', 'css');
            markup.tag.addAttribute('style', 'css');
        }
    }(Prism));
    /* **********************************************
         Begin prism-clike.js
    ********************************************** */
    Prism.languages.clike = {
        'comment': [
            {
                pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
                lookbehind: true,
                greedy: true
            },
            {
                pattern: /(^|[^\\:])\/\/.*/,
                lookbehind: true,
                greedy: true
            }
        ],
        'string': {
            pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
            greedy: true
        },
        'class-name': {
            pattern: /(\b(?:class|interface|extends|implements|trait|instanceof|new)\s+|\bcatch\s+\()[\w.\\]+/i,
            lookbehind: true,
            inside: {
                'punctuation': /[.\\]/
            }
        },
        'keyword': /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
        'boolean': /\b(?:true|false)\b/,
        'function': /\b\w+(?=\()/,
        'number': /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
        'operator': /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
        'punctuation': /[{}[\];(),.:]/
    };
    /* **********************************************
         Begin prism-javascript.js
    ********************************************** */
    Prism.languages.javascript = Prism.languages.extend('clike', {
        'class-name': [
            Prism.languages.clike['class-name'],
            {
                pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:prototype|constructor))/,
                lookbehind: true
            }
        ],
        'keyword': [
            {
                pattern: /((?:^|\})\s*)catch\b/,
                lookbehind: true
            },
            {
                pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
                lookbehind: true
            },
        ],
        // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
        'function': /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
        'number': /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/,
        'operator': /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
    });
    Prism.languages.javascript['class-name'][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;
    Prism.languages.insertBefore('javascript', 'keyword', {
        'regex': {
            // eslint-disable-next-line regexp/no-dupe-characters-character-class
            pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)\/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/,
            lookbehind: true,
            greedy: true,
            inside: {
                'regex-source': {
                    pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
                    lookbehind: true,
                    alias: 'language-regex',
                    inside: Prism.languages.regex
                },
                'regex-delimiter': /^\/|\/$/,
                'regex-flags': /^[a-z]+$/,
            }
        },
        // This must be declared before keyword because we use "function" inside the look-forward
        'function-variable': {
            pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
            alias: 'function'
        },
        'parameter': [
            {
                pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
                lookbehind: true,
                inside: Prism.languages.javascript
            },
            {
                pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
                lookbehind: true,
                inside: Prism.languages.javascript
            },
            {
                pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
                lookbehind: true,
                inside: Prism.languages.javascript
            },
            {
                pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
                lookbehind: true,
                inside: Prism.languages.javascript
            }
        ],
        'constant': /\b[A-Z](?:[A-Z_]|\dx?)*\b/
    });
    Prism.languages.insertBefore('javascript', 'string', {
        'hashbang': {
            pattern: /^#!.*/,
            greedy: true,
            alias: 'comment'
        },
        'template-string': {
            pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
            greedy: true,
            inside: {
                'template-punctuation': {
                    pattern: /^`|`$/,
                    alias: 'string'
                },
                'interpolation': {
                    pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
                    lookbehind: true,
                    inside: {
                        'interpolation-punctuation': {
                            pattern: /^\$\{|\}$/,
                            alias: 'punctuation'
                        },
                        rest: Prism.languages.javascript
                    }
                },
                'string': /[\s\S]+/
            }
        }
    });
    if (Prism.languages.markup) {
        Prism.languages.markup.tag.addInlined('script', 'javascript');
        // add attribute support for all DOM events.
        // https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events
        Prism.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, 'javascript');
    }
    Prism.languages.js = Prism.languages.javascript;
    /* **********************************************
         Begin prism-file-highlight.js
    ********************************************** */
    (function () {
        if (typeof Prism === 'undefined' || typeof document === 'undefined') {
            return;
        }
        // https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill
        if (!Element.prototype.matches) {
            Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
        }
        var LOADING_MESSAGE = 'Loading…';
        var FAILURE_MESSAGE = function (status, message) {
            return '✖ Error ' + status + ' while fetching file: ' + message;
        };
        var FAILURE_EMPTY_MESSAGE = '✖ Error: File does not exist or is empty';
        var EXTENSIONS = {
            'js': 'javascript',
            'py': 'python',
            'rb': 'ruby',
            'ps1': 'powershell',
            'psm1': 'powershell',
            'sh': 'bash',
            'bat': 'batch',
            'h': 'c',
            'tex': 'latex'
        };
        var STATUS_ATTR = 'data-src-status';
        var STATUS_LOADING = 'loading';
        var STATUS_LOADED = 'loaded';
        var STATUS_FAILED = 'failed';
        var SELECTOR = 'pre[data-src]:not([' + STATUS_ATTR + '="' + STATUS_LOADED + '"])'
            + ':not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';
        var lang = /\blang(?:uage)?-([\w-]+)\b/i;
        /**
         * Sets the Prism `language-xxxx` or `lang-xxxx` class to the given language.
         *
         * @param {HTMLElement} element
         * @param {string} language
         * @returns {void}
         */
        function setLanguageClass(element, language) {
            var className = element.className;
            className = className.replace(lang, ' ') + ' language-' + language;
            element.className = className.replace(/\s+/g, ' ').trim();
        }
        Prism.hooks.add('before-highlightall', function (env) {
            env.selector += ', ' + SELECTOR;
        });
        Prism.hooks.add('before-sanity-check', function (env) {
            var pre = /** @type {HTMLPreElement} */ (env.element);
            if (pre.matches(SELECTOR)) {
                env.code = ''; // fast-path the whole thing and go to complete
                pre.setAttribute(STATUS_ATTR, STATUS_LOADING); // mark as loading
                // add code element with loading message
                var code = pre.appendChild(document.createElement('CODE'));
                code.textContent = LOADING_MESSAGE;
                var src = pre.getAttribute('data-src');
                var language = env.language;
                if (language === 'none') {
                    // the language might be 'none' because there is no language set;
                    // in this case, we want to use the extension as the language
                    var extension = (/\.(\w+)$/.exec(src) || [, 'none'])[1];
                    language = EXTENSIONS[extension] || extension;
                }
                // set language classes
                setLanguageClass(code, language);
                setLanguageClass(pre, language);
                // preload the language
                var autoloader = Prism.plugins.autoloader;
                if (autoloader) {
                    autoloader.loadLanguages(language);
                }
                // load file
                var xhr = new XMLHttpRequest();
                xhr.open('GET', src, true);
                xhr.onreadystatechange = function () {
                    if (xhr.readyState == 4) {
                        if (xhr.status < 400 && xhr.responseText) {
                            // mark as loaded
                            pre.setAttribute(STATUS_ATTR, STATUS_LOADED);
                            // highlight code
                            code.textContent = xhr.responseText;
                            Prism.highlightElement(code);
                        }
                        else {
                            // mark as failed
                            pre.setAttribute(STATUS_ATTR, STATUS_FAILED);
                            if (xhr.status >= 400) {
                                code.textContent = FAILURE_MESSAGE(xhr.status, xhr.statusText);
                            }
                            else {
                                code.textContent = FAILURE_EMPTY_MESSAGE;
                            }
                        }
                    }
                };
                xhr.send(null);
            }
        });
        Prism.plugins.fileHighlight = {
            /**
             * Executes the File Highlight plugin for all matching `pre` elements under the given container.
             *
             * Note: Elements which are already loaded or currently loading will not be touched by this method.
             *
             * @param {ParentNode} [container=document]
             */
            highlight: function highlight(container) {
                var elements = (container || document).querySelectorAll(SELECTOR);
                for (var i = 0, element; (element = elements[i++]);) {
                    Prism.highlightElement(element);
                }
            }
        };
        var logged = false;
        /** @deprecated Use `Prism.plugins.fileHighlight.highlight` instead. */
        Prism.fileHighlight = function () {
            if (!logged) {
                console.warn('Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.');
                logged = true;
            }
            Prism.plugins.fileHighlight.highlight.apply(this, arguments);
        };
    }());
});
// https://www.json.org/json-en.html
Prism.languages.json = {
    'property': {
        pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
        lookbehind: true,
        greedy: true
    },
    'string': {
        pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
        lookbehind: true,
        greedy: true
    },
    'comment': {
        pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
        greedy: true
    },
    'number': /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
    'punctuation': /[{}[\],]/,
    'operator': /:/,
    'boolean': /\b(?:true|false)\b/,
    'null': {
        pattern: /\bnull\b/,
        alias: 'keyword'
    }
};
Prism.languages.webmanifest = Prism.languages.json;
/**
 * Original by Samuel Flores
 *
 * Adds the following new token classes:
 *     constant, builtin, variable, symbol, regex
 */
(function (Prism) {
    Prism.languages.ruby = Prism.languages.extend('clike', {
        'comment': [
            /#.*/,
            {
                pattern: /^=begin\s[\s\S]*?^=end/m,
                greedy: true
            }
        ],
        'class-name': {
            pattern: /(\b(?:class)\s+|\bcatch\s+\()[\w.\\]+/i,
            lookbehind: true,
            inside: {
                'punctuation': /[.\\]/
            }
        },
        'keyword': /\b(?:alias|and|BEGIN|begin|break|case|class|def|define_method|defined|do|each|else|elsif|END|end|ensure|extend|for|if|in|include|module|new|next|nil|not|or|prepend|protected|private|public|raise|redo|require|rescue|retry|return|self|super|then|throw|undef|unless|until|when|while|yield)\b/
    });
    var interpolation = {
        pattern: /#\{[^}]+\}/,
        inside: {
            'delimiter': {
                pattern: /^#\{|\}$/,
                alias: 'tag'
            },
            rest: Prism.languages.ruby
        }
    };
    delete Prism.languages.ruby.function;
    Prism.languages.insertBefore('ruby', 'keyword', {
        'regex': [
            {
                pattern: RegExp(/%r/.source + '(?:' + [
                    /([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
                    /\((?:[^()\\]|\\[\s\S])*\)/.source,
                    // Here we need to specifically allow interpolation
                    /\{(?:[^#{}\\]|#(?:\{[^}]+\})?|\\[\s\S])*\}/.source,
                    /\[(?:[^\[\]\\]|\\[\s\S])*\]/.source,
                    /<(?:[^<>\\]|\\[\s\S])*>/.source
                ].join('|') + ')' + /[egimnosux]{0,6}/.source),
                greedy: true,
                inside: {
                    'interpolation': interpolation
                }
            },
            {
                pattern: /(^|[^/])\/(?!\/)(?:\[[^\r\n\]]+\]|\\.|[^[/\\\r\n])+\/[egimnosux]{0,6}(?=\s*(?:$|[\r\n,.;})#]))/,
                lookbehind: true,
                greedy: true,
                inside: {
                    'interpolation': interpolation
                }
            }
        ],
        'variable': /[@$]+[a-zA-Z_]\w*(?:[?!]|\b)/,
        'symbol': {
            pattern: /(^|[^:]):[a-zA-Z_]\w*(?:[?!]|\b)/,
            lookbehind: true
        },
        'method-definition': {
            pattern: /(\bdef\s+)[\w.]+/,
            lookbehind: true,
            inside: {
                'function': /\w+$/,
                rest: Prism.languages.ruby
            }
        }
    });
    Prism.languages.insertBefore('ruby', 'number', {
        'builtin': /\b(?:Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Stat|Fixnum|Float|Hash|Integer|IO|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|String|Struct|TMS|Symbol|ThreadGroup|Thread|Time|TrueClass)\b/,
        'constant': /\b[A-Z]\w*(?:[?!]|\b)/
    });
    Prism.languages.ruby.string = [
        {
            pattern: RegExp(/%[qQiIwWxs]?/.source + '(?:' + [
                /([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
                /\((?:[^()\\]|\\[\s\S])*\)/.source,
                // Here we need to specifically allow interpolation
                /\{(?:[^#{}\\]|#(?:\{[^}]+\})?|\\[\s\S])*\}/.source,
                /\[(?:[^\[\]\\]|\\[\s\S])*\]/.source,
                /<(?:[^<>\\]|\\[\s\S])*>/.source
            ].join('|') + ')'),
            greedy: true,
            inside: {
                'interpolation': interpolation
            }
        },
        {
            pattern: /("|')(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|(?!\1)[^\\#\r\n])*\1/,
            greedy: true,
            inside: {
                'interpolation': interpolation
            }
        },
        {
            pattern: /<<[-~]?([a-z_]\w*)[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
            alias: 'heredoc-string',
            greedy: true,
            inside: {
                'delimiter': {
                    pattern: /^<<[-~]?[a-z_]\w*|[a-z_]\w*$/i,
                    alias: 'symbol',
                    inside: {
                        'punctuation': /^<<[-~]?/
                    }
                },
                'interpolation': interpolation
            }
        },
        {
            pattern: /<<[-~]?'([a-z_]\w*)'[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
            alias: 'heredoc-string',
            greedy: true,
            inside: {
                'delimiter': {
                    pattern: /^<<[-~]?'[a-z_]\w*'|[a-z_]\w*$/i,
                    alias: 'symbol',
                    inside: {
                        'punctuation': /^<<[-~]?'|'$/,
                    }
                }
            }
        }
    ];
    Prism.languages.rb = Prism.languages.ruby;
}(Prism));
/**
 * @description
 * The `<chef-snippet>` atom is used to display syntax-highlighted code blocks.
 *
 * As of 2018.10.25 the default supported languages are:
 *
 *  -  markup (and aliases xml, html mathml, and svg)
 *  -  javascript (and alias js)
 *  -  css
 *  -  clike (read this one as "like the C language")
 *
 * Automate is configured to use these additional languages as well:
 *
 *  -  json
 *  -  ruby
 *
 * @example
 * <chef-snippet code="<h1>Highlight me</h1>"></chef-snippet>
 *
 * @example
 * <details style="margin:1em;cursor:pointer;">
 *   <summary>Example Snippet</summary>
 *   <chef-snippet code="const el = document.querySelector('h1');" lang="js"></chef-snippet>
 * </details>
 */
var ChefSnippet = /** @class */ (function () {
    function ChefSnippet(hostRef) {
        registerInstance(this, hostRef);
        /**
         * The code snippet to be highlighted.
         */
        this.code = '';
        /**
         * The language the code snippet is written in.
         * See the "Description" for active languages and http://prismjs.com/#languages-list for
         * a list of all available languages.
         */
        this.lang = 'html';
    }
    ChefSnippet.prototype.render = function () {
        var highlighted = this.highlight(this.code, this.lang);
        return (this.code.length ? (h("pre", { innerHTML: highlighted })) : '');
    };
    ChefSnippet.prototype.highlight = function (code, lang) {
        if (lang === void 0) { lang = 'html'; }
        var grammar = prism.languages[lang];
        // If the grammar rules for the specified language are unavailable then
        // default to 'none' (no color highlighting, formatted plain text only)
        if (!grammar) {
            grammar = {};
            lang = 'none';
        }
        return prism.highlight(code, grammar, lang);
    };
    Object.defineProperty(ChefSnippet, "style", {
        get: function () { return "chef-snippet{display:block;--token-comment:#898ea4;--token-punctuation:#5e6687;--token-operator:#c76b29;--token-property:#c08b30;--token-tag:#3d8fd1;--token-string:#22a2c9;--token-selector:#6679cc;--token-attr-name:#c76b29;--token-attr-value:#ac9739;--token-entity:#22a2c9;--token-statement:#22a2c9;--token-placeholder:#3d8fd1;--token-inserted:#202746;--token-important:#c94922}chef-snippet pre{padding:1em;margin:0;overflow:auto;font-family:Consolas,Menlo,Monaco,Courier,monospace;font-size:14px;background:var(--chef-white);color:var(--chef-dark-grey);line-height:1.5em;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal}chef-snippet .token.cdata,chef-snippet .token.comment,chef-snippet .token.doctype,chef-snippet .token.prolog{color:var(--token-comment)}chef-snippet .token.punctuation{color:var(--token-punctuation)}chef-snippet .token.namespace{opacity:.7}chef-snippet .token.boolean,chef-snippet .token.number,chef-snippet .token.operator{color:var(--token-operator)}chef-snippet .token.property{color:var(--token-property)}chef-snippet .token.tag{color:var(--token-tag)}chef-snippet .token.string{color:var(--token-string)}chef-snippet .token.selector{color:var(--token-selector)}chef-snippet .token.attr-name{color:var(--token-attr-name)}chef-snippet .token.attr-value,chef-snippet .token.control,chef-snippet .token.directive,chef-snippet .token.keyword,chef-snippet .token.unit{color:var(--token-attr-value)}chef-snippet .language-css .token.string,chef-snippet .style .token.string,chef-snippet .token.entity,chef-snippet .token.url{color:var(--token-entity)}chef-snippet .token.atrule,chef-snippet .token.regex,chef-snippet .token.statement{color:var(--token-statement)}chef-snippet .token.placeholder,chef-snippet .token.variable{color:var(--token-placeholder)}chef-snippet .token.deleted{text-decoration:line-through}chef-snippet .token.inserted{border-bottom:1px dotted var(--token-inserted);text-decoration:none}chef-snippet .token.italic{font-style:italic}chef-snippet .token.bold,chef-snippet .token.important{font-weight:700}chef-snippet .token.important{color:var(--token-important)}chef-snippet .token.entity{cursor:help}"; },
        enumerable: true,
        configurable: true
    });
    return ChefSnippet;
}());
export { ChefExample as chef_example, ChefMarkdown as chef_markdown, ChefSnippet as chef_snippet };
