-module(auth_hand_saml_consume_tests).

-include("auth_types.hrl").
-include_lib("hoax/include/hoax.hrl").
-include_lib("esaml/include/esaml.hrl").

-compile(export_all).

hoax_fixture_test_() ->
    hoax:fixture(?MODULE).

handle_when_assertion_is_valid_and_token_is_assigned_redirects_to_login_with_session_cookie() ->
    EntName = <<"testEnt">>,
    UserName = <<"kimmy">>,
    Cert =  <<"x509abcabcabc">>,
    Relay = [],
    Assertion = #esaml_assertion{recipient = "foo",
                                 issuer = "bomb.com",
                                 subject = #esaml_subject{name = "kimmy"},
                                 attributes = []},
    hoax:mock(deliv_web_utils,
              ?expect(extract_bindings,
                      ?withArgs([[ent_name], req]),
                      ?andReturn({[EntName], req1}))),
    hoax:mock(auth_saml_cowboy,
              ?expect(extract_saml_params,
                      ?withArgs([req1]),
                      ?andReturn({saml_encoding, saml_response, Relay, req2}))),
    hoax:mock(auth_saml_config, [
              ?expect(identity_provider,
                      ?withArgs([EntName]),
                      ?andReturn({ok,
                                  #esaml_idp_metadata{certificates = [Cert]},
                                  sso_binding,
                                  name_id})),
              ?expect(service_provider,
                      ?withArgs([EntName, [Cert]]),
                      ?andReturn({ok, service_provider_config}))]),
    hoax:mock(auth_saml_cowboy,
              ?expect(validate_assertion,
                      ?withArgs([service_provider_config, saml_encoding, saml_response]),
                      ?andReturn({ok, Assertion}))),
    hoax:mock(deliv_user, [
              ?expect(fetch,
                      ?withArgs([EntName, UserName]),
                      ?andReturn({ok, user_record})),
              ?expect(getval,
                      ?withArgs([user_type, user_record]),
                      ?andReturn(<<"saml">>))]),
    hoax:mock(deliv_token,
              ?expect(assign_token,
                      ?withArgs([EntName, UserName]),
                      ?andReturn({ok, token}))),
    hoax:mock(auth_saml_utils,
              ?expect(redirect_with_session,
                      ?withArgs([EntName, UserName, token, Relay, req2, state]),
                      ?andReturn({ok, req3, state}))),

    Actual = auth_hand_saml_consume:handle(req, state),
    ?assertEqual({ok, req3, state}, Actual),
    ?verifyAll.

handle_when_assertion_is_valid_and_token_is_assigned_and_relaystate_includes_return_url_returns_login_url_with_returnUrl_parameter() ->
    EntName = <<"testEnt">>,
    UserName = <<"kimmy">>,
    Cert =  <<"x509abcabcabc">>,
    Assertion = #esaml_assertion{recipient = "foo",
                                 issuer = "bomb.com",
                                 subject = #esaml_subject{name = "kimmy"},
                                 attributes = []},
    Relay = [{return_url, <<"some%2Furl">>}],
    hoax:mock(deliv_web_utils,
              ?expect(extract_bindings,
                      ?withArgs([[ent_name], req]),
                      ?andReturn({[EntName], req1}))),
    hoax:mock(auth_saml_cowboy,
              ?expect(extract_saml_params,
                      ?withArgs([req1]),
                      ?andReturn({saml_encoding, saml_response, Relay, req2}))),
    hoax:mock(auth_saml_config, [
              ?expect(identity_provider,
                      ?withArgs([EntName]),
                      ?andReturn({ok,
                                  #esaml_idp_metadata{certificates = [Cert]},
                                  sso_binding,
                                  name_id})),
              ?expect(service_provider,
                      ?withArgs([EntName, [Cert]]),
                      ?andReturn({ok, service_provider_config}))]),
    hoax:mock(auth_saml_cowboy,
              ?expect(validate_assertion,
                      ?withArgs([service_provider_config, saml_encoding, saml_response]),
                      ?andReturn({ok, Assertion}))),
    hoax:mock(deliv_user, [
              ?expect(fetch,
                      ?withArgs([EntName, UserName]),
                      ?andReturn({ok, user_record})),
              ?expect(getval,
                      ?withArgs([user_type, user_record]),
                      ?andReturn(<<"saml">>))]),
    hoax:mock(deliv_token,
              ?expect(assign_token,
                      ?withArgs([EntName, UserName]),
                      ?andReturn({ok, token}))),
    hoax:mock(auth_saml_utils,
              ?expect(redirect_with_session,
                      ?withArgs([EntName, UserName, token, Relay, req2, state]),
                      ?andReturn({ok, req3, state}))),

    Actual = auth_hand_saml_consume:handle(req, state),
    ?assertEqual({ok, req3, state}, Actual),
    ?verifyAll.

handle_when_assertion_is_valid_and_token_fails_redirects_to_error_page() ->
    EntName = <<"testEnt">>,
    UserName = <<"kimmy">>,
    Cert =  <<"x509abcabcabc">>,
    Assertion = #esaml_assertion{recipient = "foo",
                                 issuer = "bomb.com",
                                 subject = #esaml_subject{name = "kimmy"},
                                 attributes = []},
    hoax:mock(deliv_web_utils,
              ?expect(extract_bindings,
                      ?withArgs([[ent_name], req]),
                      ?andReturn({[EntName], req1}))),
    hoax:mock(auth_saml_cowboy,
              ?expect(extract_saml_params,
                      ?withArgs([req1]),
                      ?andReturn({saml_encoding, saml_response, [], req2}))),
    hoax:mock(auth_saml_config, [
              ?expect(identity_provider,
                      ?withArgs([EntName]),
                      ?andReturn({ok,
                                  #esaml_idp_metadata{certificates = [Cert]},
                                  sso_binding,
                                  name_id})),
              ?expect(service_provider,
                      ?withArgs([EntName, [Cert]]),
                      ?andReturn({ok, service_provider_config}))]),
    hoax:mock(auth_saml_cowboy,
              ?expect(validate_assertion,
                      ?withArgs([service_provider_config, saml_encoding, saml_response]),
                      ?andReturn({ok, Assertion}))),
    hoax:mock(deliv_user, [
              ?expect(fetch,
                      ?withArgs([EntName, UserName]),
                      ?andReturn({ok, user_record})),
              ?expect(getval,
                      ?withArgs([user_type, user_record]),
                      ?andReturn(<<"saml">>))]),
    hoax:mock(deliv_token,
              ?expect(assign_token,
                      ?withArgs([EntName, UserName]),
                      ?andReturn({error, reason}))),
    hoax:mock(auth_saml_utils,
              ?expect(login_url_with_error_param,
                      ?withArgs([EntName, <<"SAML login failed!">>]),
                      ?andReturn(location))),
    hoax:mock(deliv_web_utils,
              ?expect(redirect_302,
                      ?withArgs([location, req2, state]),
                      ?andReturn({ok, req3, state}))),

    Actual = auth_hand_saml_consume:handle(req, state),
    ?assertEqual({ok, req3, state}, Actual),
    ?verifyAll.

handle_when_saml_config_not_present_redirects_to_error_page() ->
    EntName = <<"testEnt">>,
    hoax:mock(deliv_web_utils,
              ?expect(extract_bindings,
                      ?withArgs([[ent_name], req]),
                      ?andReturn({[EntName], req1}))),
    hoax:mock(auth_saml_cowboy,
              ?expect(extract_saml_params,
                      ?withArgs([req1]),
                      ?andReturn({saml_encoding, saml_response, [], req2}))),
    hoax:mock(auth_saml_config,
              ?expect(identity_provider,
                      ?withArgs([EntName]),
                      ?andReturn({error, not_found}))),
    hoax:mock(deliv_web_utils,
              ?expect(redirect_302,
                      ?withArgs([location, req2, state]),
                      ?andReturn({ok, req3, state}))),
    hoax:mock(auth_saml_utils,
              ?expect(login_url_with_error_param,
                      ?withArgs([EntName, <<"SAML configuration invalid, login failed!">>]),
                      ?andReturn(location))),

    Actual = auth_hand_saml_consume:handle(req, state),
    ?assertEqual({ok, req3, state}, Actual),
    ?verifyAll.

handle_when_assertion_is_not_valid_redirects_to_error_page() ->
    EntName = <<"testEnt">>,
    Cert =  <<"x509abcabcabc">>,
    hoax:mock(deliv_web_utils,
              ?expect(extract_bindings,
                      ?withArgs([[ent_name], req]),
                      ?andReturn({[EntName], req1}))),
    hoax:mock(auth_saml_cowboy,
              ?expect(extract_saml_params,
                      ?withArgs([req1]),
                      ?andReturn({saml_encoding, saml_response, [], req2}))),
    hoax:mock(auth_saml_config, [
              ?expect(identity_provider,
                      ?withArgs([EntName]),
                      ?andReturn({ok,
                                  #esaml_idp_metadata{certificates = [Cert]},
                                  sso_binding,
                                  name_id})),
              ?expect(service_provider,
                      ?withArgs([EntName, [Cert]]),
                      ?andReturn({ok, service_provider_config}))]),
    hoax:mock(auth_saml_cowboy,
              ?expect(validate_assertion,
                      ?withArgs([service_provider_config, saml_encoding, saml_response]),
                      ?andReturn({error, <<"Some failure">>}))),
    hoax:mock(deliv_web_utils, [
              ?expect(redirect_302,
                      ?withArgs([location, req2, state]),
                      ?andReturn({ok, req3, state}))]),
    hoax:mock(auth_saml_utils,
              ?expect(login_url_with_error_param,
                      ?withArgs([EntName, <<"SAML login failed!">>]),
                      ?andReturn(location))),

    Actual = auth_hand_saml_consume:handle(req, state),
    ?assertEqual({ok, req3, state}, Actual),
    ?verifyAll.

handle_when_assertion_is_valid_and_okta_attributes_present_updates_user() ->
    EntName = <<"testEnt">>,
    UserName = <<"kimmy">>,
    FetchedUser = deliv_user:fromlist([{name, UserName},
                                       {first_name, <<"JP">>},
                                       {last_name, <<"Morgan">>},
                                       {email, <<"JP@chase.com">>}]),
    ExpectedUser = deliv_user:fromlist([{name, UserName},
                                        {first_name, <<"Saml">>},
                                        {last_name, <<"Jackson">>},
                                        {email, <<"saml@saml.io">>}]),
    PropList = [{email, "saml@saml.io"},
                {last_name, "Jackson"},
                {first_name, "Saml"}],
    Cert =  <<"x509abcabcabc">>,
    Relay = [],
    Assertion = #esaml_assertion{recipient = "foo",
                                 issuer = "bomb.com",
                                 subject = #esaml_subject{name = "kimmy"},
                                 attributes = [{email,"saml@saml.io"},{lastName,"Jackson"},{firstName,"Saml"}]},
    hoax:mock(deliv_web_utils,
              ?expect(extract_bindings,
                      ?withArgs([[ent_name], req]),
                      ?andReturn({[EntName], req1}))),
    hoax:mock(auth_saml_cowboy,
              ?expect(extract_saml_params,
                      ?withArgs([req1]),
                      ?andReturn({saml_encoding, saml_response, Relay, req2}))),
    hoax:mock(auth_saml_config, [
              ?expect(identity_provider,
                      ?withArgs([EntName]),
                      ?andReturn({ok,
                                  #esaml_idp_metadata{certificates = [Cert]},
                                  sso_binding,
                                  name_id})),
              ?expect(service_provider,
                      ?withArgs([EntName, [Cert]]),
                      ?andReturn({ok, service_provider_config}))]),
    hoax:mock(auth_saml_cowboy,
              ?expect(validate_assertion,
                      ?withArgs([service_provider_config, saml_encoding, saml_response]),
                      ?andReturn({ok, Assertion}))),
    hoax:mock(deliv_token,
              ?expect(assign_token,
                      ?withArgs([EntName, UserName]),
                      ?andReturn({ok, token}))),
    hoax:mock(deliv_user, [
              ?expect(fetch,
                      ?withArgs([EntName, UserName]),
                      ?andReturn({ok, FetchedUser})),
              ?expect(getval,
                      ?withArgs([user_type, FetchedUser]),
                      ?andReturn(<<"saml">>)),
              ?expect(update,
                      ?withArgs([ExpectedUser]),
                       ?andReturn({ok, ExpectedUser})),
              ?expect(setvals,
                      ?withArgs([PropList, FetchedUser]),
                      ?andReturn(ExpectedUser))]),
    hoax:mock(auth_saml_utils,
              ?expect(redirect_with_session,
                      ?withArgs([EntName, UserName, token, Relay, req2, state]),
                      ?andReturn({ok, req3, state}))),

    Actual = auth_hand_saml_consume:handle(req, state),
    ?assertEqual({ok, req3, state}, Actual),
    ?verifyAll.

handle_when_assertion_is_valid_and_extra_attributes_present_updates_user_with_expected_attributes() ->
    EntName = <<"testEnt">>,
    UserName = <<"kimmy">>,
    FetchedUser = deliv_user:fromlist([{name, UserName},
                                       {first_name, <<"JP">>},
                                       {last_name, <<"Morgan">>},
                                       {email, <<"JP@chase.com">>}]),
    ExpectedUser = deliv_user:fromlist([{name, UserName},
                                        {first_name, <<"Saml">>},
                                        {last_name, <<"Jackson">>},
                                        {email, <<"saml@saml.io">>}]),
    PropList = [{email, "saml@saml.io"},
                {last_name, "Jackson"},
                {first_name, "Saml"}],
    Cert =  <<"x509abcabcabc">>,
    Relay = [],
    Assertion = #esaml_assertion{recipient = "foo",
                                 issuer = "bomb.com",
                                 subject = #esaml_subject{name = "kimmy"},
                                 attributes = [{email,"saml@saml.io"},{unknown,"Mysteries"},{lastName,"Jackson"},{firstName,"Saml"}]},
    hoax:mock(deliv_web_utils,
              ?expect(extract_bindings,
                      ?withArgs([[ent_name], req]),
                      ?andReturn({[EntName], req1}))),
    hoax:mock(auth_saml_cowboy,
              ?expect(extract_saml_params,
                      ?withArgs([req1]),
                      ?andReturn({saml_encoding, saml_response, Relay, req2}))),
    hoax:mock(auth_saml_config, [
              ?expect(identity_provider,
                      ?withArgs([EntName]),
                      ?andReturn({ok,
                                  #esaml_idp_metadata{certificates = [Cert]},
                                  sso_binding,
                                  name_id})),
              ?expect(service_provider,
                      ?withArgs([EntName, [Cert]]),
                      ?andReturn({ok, service_provider_config}))]),
    hoax:mock(auth_saml_cowboy,
              ?expect(validate_assertion,
                      ?withArgs([service_provider_config, saml_encoding, saml_response]),
                      ?andReturn({ok, Assertion}))),
    hoax:mock(deliv_token,
              ?expect(assign_token,
                      ?withArgs([EntName, UserName]),
                      ?andReturn({ok, token}))),
    hoax:mock(deliv_user, [
              ?expect(fetch,
                      ?withArgs([EntName,   UserName]),
                      ?andReturn({ok, FetchedUser})),
              ?expect(getval,
                      ?withArgs([user_type, FetchedUser]),
                      ?andReturn(<<"saml">>)),
              ?expect(update,
                      ?withArgs([ExpectedUser]),
                       ?andReturn({ok, ExpectedUser})),
              ?expect(setvals,
                      ?withArgs([PropList, FetchedUser]),
                      ?andReturn(ExpectedUser))]),
    hoax:mock(auth_saml_utils,
              ?expect(redirect_with_session,
                      ?withArgs([EntName, UserName, token, Relay, req2, state]),
                      ?andReturn({ok, req3, state}))),

    Actual = auth_hand_saml_consume:handle(req, state),
    ?assertEqual({ok, req3, state}, Actual),
    ?verifyAll.

handle_when_assertion_is_valid_and_no_attributes_present_and_user_not_found_creates_new_user() ->
    EntName = <<"testEnt">>,
    UserName = <<"kimmy">>,
    Cert =  <<"x509abcabcabc">>,
    Relay = [],
    Assertion = #esaml_assertion{recipient = "foo",
                                 issuer = "bomb.com",
                                 subject = #esaml_subject{name = "kimmy"},
                                 attributes = []},
    hoax:mock(deliv_web_utils,
              ?expect(extract_bindings,
                      ?withArgs([[ent_name], req]),
                      ?andReturn({[EntName], req1}))),
    hoax:mock(auth_saml_cowboy,
              ?expect(extract_saml_params,
                      ?withArgs([req1]),
                      ?andReturn({saml_encoding, saml_response, [], req2}))),
    hoax:mock(auth_saml_config, [
              ?expect(identity_provider,
                      ?withArgs([EntName]),
                      ?andReturn({ok,
                                  #esaml_idp_metadata{certificates = [Cert]},
                                  sso_binding,
                                  name_id})),
              ?expect(service_provider,
                      ?withArgs([EntName, [Cert]]),
                      ?andReturn({ok, service_provider_config})),
              ?expect(fetch,
                      ?withArgs([EntName]),
                      ?andReturn({ok, #saml_config{default_roles = [<<"observer">>]}}))]),
    hoax:mock(auth_saml_cowboy,
              ?expect(validate_assertion,
                      ?withArgs([service_provider_config, saml_encoding, saml_response]),
                      ?andReturn({ok, Assertion}))),
    hoax:mock(deliv_user, [
              ?expect(fetch,
                      ?withArgs([EntName, UserName]),
                      ?andReturn({error, not_found})),
              ?expect(insert,
                      ?withArgs([EntName, [{name, UserName},
                                           {user_type, <<"saml">>}]]),
                      ?andReturn([user])),
              ?expect(edit_roles,
                      ?withArgs([grant, enterprise, [EntName, UserName, [<<"observer">>]]]),
                      ?andReturn(ejson))]),
    hoax:mock(auth_saml_utils,
              ?expect(redirect_with_session,
                      ?withArgs([EntName, UserName, token, Relay, req2, state]),
                      ?andReturn({ok, req3, state}))),
    hoax:mock(deliv_token,
              ?expect(assign_token,
                      ?withArgs([EntName, UserName]),
                      ?andReturn({ok, token}))),
    Actual = auth_hand_saml_consume:handle(req, state),
    ?assertEqual({ok, req3, state}, Actual),
    ?verifyAll.

handle_when_assertion_is_valid_and_attributes_present_but_update_fails_redirects_to_error_page() ->
    EntName = <<"testEnt">>,
    UserName = <<"kimmy">>,
    Cert =  <<"x509abcabcabc">>,
    PropList = [{email, "saml@saml.io"},
                {last_name, "Jackson"},
                {first_name, "Saml"}],
    Assertion = #esaml_assertion{recipient = "foo",
                                 issuer = "bomb.com",
                                 subject = #esaml_subject{name = "kimmy"},
                                 attributes = [{email,"saml@saml.io"},{lastName,"Jackson"},{firstName,"Saml"}]},
    hoax:mock(deliv_web_utils,
              ?expect(extract_bindings,
                      ?withArgs([[ent_name], req]),
                      ?andReturn({[EntName], req1}))),
    hoax:mock(auth_saml_cowboy,
              ?expect(extract_saml_params,
                      ?withArgs([req1]),
                      ?andReturn({saml_encoding, saml_response, [], req2}))),
    hoax:mock(auth_saml_config, [
              ?expect(identity_provider,
                      ?withArgs([EntName]),
                      ?andReturn({ok,
                                  #esaml_idp_metadata{certificates = [Cert]},
                                  sso_binding,
                                  name_id})),
              ?expect(service_provider,
                      ?withArgs([EntName, [Cert]]),
                      ?andReturn({ok, service_provider_config}))]),
    hoax:mock(auth_saml_cowboy,
              ?expect(validate_assertion,
                      ?withArgs([service_provider_config, saml_encoding, saml_response]),
                      ?andReturn({ok, Assertion}))),
    hoax:mock(deliv_web_utils,
              ?expect(redirect_302,
                      ?withArgs([location, req2, state]),
                      ?andReturn({ok, req3, state}))),
    hoax:mock(deliv_user, [
              ?expect(fetch,
                      ?withArgs([EntName, UserName]),
                      ?andReturn({ok, user})),
              ?expect(getval,
                      ?withArgs([user_type, user]),
                      ?andReturn(<<"saml">>)),
              ?expect(update,
                      ?withArgs([user]),
                      ?andReturn({error, error})),
              ?expect(setvals,
                      ?withArgs([PropList, user]),
                      ?andReturn(user))]),
    hoax:mock(auth_saml_utils,
             ?expect(login_url_with_error_param,
                     ?withArgs([EntName, <<"Invalid user, login failed!">>]),
                     ?andReturn(location))),
    Actual = auth_hand_saml_consume:handle(req, state),
    ?assertEqual({ok, req3, state}, Actual),
    ?verifyAll.

handle_when_assertion_is_valid_but_user_is_not_saml_user_type_redirects_to_error_page() ->
    EntName = <<"testEnt">>,
    UserName = <<"kimmy">>,
    Cert =  <<"x509abcabcabc">>,
    User = deliv_user:fromlist([{name, UserName}, {user_type, <<"internal">>}]),
    Assertion = #esaml_assertion{recipient = "foo",
                                 issuer = "bomb.com",
                                 subject = #esaml_subject{name = "kimmy"},
                                 attributes = []},
    hoax:mock(deliv_web_utils,
              ?expect(extract_bindings,
                      ?withArgs([[ent_name], req]),
                      ?andReturn({[EntName], req1}))),
    hoax:mock(auth_saml_cowboy,
              ?expect(extract_saml_params,
                      ?withArgs([req1]),
                      ?andReturn({saml_encoding, saml_response, [], req2}))),
    hoax:mock(auth_saml_config, [
              ?expect(identity_provider,
                      ?withArgs([EntName]),
                      ?andReturn({ok,
                                  #esaml_idp_metadata{certificates = [Cert]},
                                  sso_binding,
                                  name_id})),
              ?expect(service_provider,
                      ?withArgs([EntName, [Cert]]),
                      ?andReturn({ok, service_provider_config}))]),
    hoax:mock(auth_saml_cowboy,
              ?expect(validate_assertion,
                      ?withArgs([service_provider_config, saml_encoding, saml_response]),
                      ?andReturn({ok, Assertion}))),
    hoax:mock(deliv_web_utils,
              ?expect(redirect_302,
                      ?withArgs([location, req2, state]),
                      ?andReturn({ok, req3, state}))),
    hoax:mock(deliv_user, [
              ?expect(fetch,
                      ?withArgs([EntName, UserName]),
                      ?andReturn({ok, User})),
              ?expect(getval,
                      ?withArgs([user_type, User]),
                      ?andReturn(<<"internal">>))]),
    hoax:mock(auth_saml_utils,
             ?expect(login_url_with_error_param,
                     ?withArgs([EntName, <<"SAML login failed. Please sign in with username and password.">>]),
                     ?andReturn(location))),
    Actual = auth_hand_saml_consume:handle(req, state),
    ?assertEqual({ok, req3, state}, Actual),
    ?verifyAll.

handle_when_assertion_is_valid_and_attributes_present_but_user_not_found_creates_new_user_with_attributes() ->
    EntName = <<"testEnt">>,
    UserName = <<"kimmy">>,
    Cert =  <<"x509abcabcabc">>,
    Relay = [],
    Assertion = #esaml_assertion{recipient = "foo",
                                 issuer = "bomb.com",
                                 subject = #esaml_subject{name = "kimmy"},
                                 attributes = [{email,"saml@saml.io"},{lastName,"Jackson"},{firstName,"Saml"}]},
    ExpectedPropList = [{name, UserName},
                        {user_type, <<"saml">>},
                        {email,"saml@saml.io"},
                        {last_name,"Jackson"},
                        {first_name,"Saml"}],
    hoax:mock(deliv_web_utils,
              ?expect(extract_bindings,
                      ?withArgs([[ent_name], req]),
                      ?andReturn({[EntName], req1}))),
    hoax:mock(auth_saml_cowboy,
              ?expect(extract_saml_params,
                      ?withArgs([req1]),
                      ?andReturn({saml_encoding, saml_response, [], req2}))),
    hoax:mock(auth_saml_config, [
              ?expect(identity_provider,
                      ?withArgs([EntName]),
                      ?andReturn({ok,
                                  #esaml_idp_metadata{certificates = [Cert]},
                                  sso_binding,
                                  name_id})),
              ?expect(service_provider,
                      ?withArgs([EntName, [Cert]]),
                      ?andReturn({ok, service_provider_config})),
              ?expect(fetch,
                      ?withArgs([EntName]),
                      ?andReturn({ok, #saml_config{default_roles = [<<"observer">>]}}))]),
    hoax:mock(auth_saml_cowboy,
              ?expect(validate_assertion,
                      ?withArgs([service_provider_config, saml_encoding, saml_response]),
                      ?andReturn({ok, Assertion}))),
    hoax:mock(deliv_user, [
              ?expect(fetch,
                      ?withArgs([EntName, UserName]),
                      ?andReturn({error, not_found})),
              ?expect(insert,
                      ?withArgs([EntName, ExpectedPropList]),
                      ?andReturn([user])),
              ?expect(edit_roles,
                      ?withArgs([grant, enterprise, [EntName, UserName, [<<"observer">>]]]),
                      ?andReturn(ejson))]),
    hoax:mock(auth_saml_utils,
              ?expect(redirect_with_session,
                      ?withArgs([EntName, UserName, token, Relay, req2, state]),
                      ?andReturn({ok, req3, state}))),
    hoax:mock(deliv_token,
             ?expect(assign_token,
                     ?withArgs([EntName, UserName]),
                     ?andReturn({ok, token}))),

    Actual = auth_hand_saml_consume:handle(req, state),
    ?assertEqual({ok, req3, state}, Actual),
    ?verifyAll.

handle_when_assertion_is_valid_and_attributes_present_and_user_not_found_and_user_create_fails_redirects_to_login_with_error() ->
    EntName = <<"testEnt">>,
    UserName = <<"kimmy">>,
    Cert =  <<"x509abcabcabc">>,
    Assertion = #esaml_assertion{recipient = "foo",
                                 issuer = "bomb.com",
                                 subject = #esaml_subject{name = "kimmy"},
                                 attributes = [{email,"saml@saml.io"},{lastName,"Jackson"},{firstName,"Saml"}]},
    ExpectedPropList = [{name, UserName},
                        {user_type, <<"saml">>},
                        {email,"saml@saml.io"},
                        {last_name,"Jackson"},
                        {first_name,"Saml"}],
    hoax:mock(deliv_web_utils,
              ?expect(extract_bindings,
                      ?withArgs([[ent_name], req]),
                      ?andReturn({[EntName], req1}))),
    hoax:mock(auth_saml_cowboy,
              ?expect(extract_saml_params,
                      ?withArgs([req1]),
                      ?andReturn({saml_encoding, saml_response, [], req2}))),
    hoax:mock(auth_saml_config, [
              ?expect(identity_provider,
                      ?withArgs([EntName]),
                      ?andReturn({ok,
                                  #esaml_idp_metadata{certificates = [Cert]},
                                  sso_binding,
                                  name_id})),
              ?expect(service_provider,
                      ?withArgs([EntName, [Cert]]),
                      ?andReturn({ok, service_provider_config}))]),
    hoax:mock(auth_saml_cowboy,
              ?expect(validate_assertion,
                      ?withArgs([service_provider_config, saml_encoding, saml_response]),
                      ?andReturn({ok, Assertion}))),
    hoax:mock(deliv_user, [
              ?expect(fetch,
                      ?withArgs([EntName, UserName]),
                      ?andReturn({error, not_found})),
              ?expect(insert,
                      ?withArgs([EntName, ExpectedPropList]),
                      ?andReturn({error, not_ok}))]),
    hoax:mock(auth_saml_utils,
              ?expect(login_url_with_error_param,
                      ?withArgs([EntName, <<"Invalid user, login failed!">>]),
                      ?andReturn(location))),
    hoax:mock(deliv_web_utils,
              ?expect(redirect_302,
                      ?withArgs([location, req2, state]),
                      ?andReturn({ok, req3, state}))),

    Actual = auth_hand_saml_consume:handle(req, state),
    ?assertEqual({ok, req3, state}, Actual),
    ?verifyAll.

handle_when_assertion_is_valid_and_attributes_present_and_user_not_found_and_user_create_succeeds_but_roles_grant_fails_redirects_to_login_with_error() ->
    EntName = <<"testEnt">>,
    UserName = <<"kimmy">>,
    Cert =  <<"x509abcabcabc">>,
    Assertion = #esaml_assertion{recipient = "foo",
                                 issuer = "bomb.com",
                                 subject = #esaml_subject{name = "kimmy"},
                                 attributes = [{email,"saml@saml.io"},{lastName,"Jackson"},{firstName,"Saml"}]},
    ExpectedPropList = [{name, UserName},
                        {user_type, <<"saml">>},
                        {email,"saml@saml.io"},
                        {last_name,"Jackson"},
                        {first_name,"Saml"}],
    hoax:mock(deliv_web_utils,
              ?expect(extract_bindings,
                      ?withArgs([[ent_name], req]),
                      ?andReturn({[EntName], req1}))),
    hoax:mock(auth_saml_cowboy,
              ?expect(extract_saml_params,
                      ?withArgs([req1]),
                      ?andReturn({saml_encoding, saml_response, [], req2}))),
    hoax:mock(auth_saml_config, [
              ?expect(identity_provider,
                      ?withArgs([EntName]),
                      ?andReturn({ok,
                                  #esaml_idp_metadata{certificates = [Cert]},
                                  sso_binding,
                                  name_id})),
              ?expect(service_provider,
                      ?withArgs([EntName, [Cert]]),
                      ?andReturn({ok, service_provider_config})),
              ?expect(fetch,
                      ?withArgs([EntName]),
                      ?andReturn({ok, #saml_config{default_roles = [<<"observer">>]}}))]),
    hoax:mock(auth_saml_cowboy,
              ?expect(validate_assertion,
                      ?withArgs([service_provider_config, saml_encoding, saml_response]),
                      ?andReturn({ok, Assertion}))),
    hoax:mock(deliv_user, [
              ?expect(fetch,
                      ?withArgs([EntName, UserName]),
                      ?andReturn({error, not_found})),
              ?expect(insert,
                      ?withArgs([EntName, ExpectedPropList]),
                      ?andReturn([user])),
              ?expect(edit_roles,
                      ?withArgs([grant, enterprise, [EntName, UserName, [<<"observer">>]]]),
                      ?andReturn({error, not_ok}))]),
    hoax:mock(auth_saml_utils,
              ?expect(login_url_with_error_param,
                      ?withArgs([EntName, <<"Invalid user, login failed!">>]),
                      ?andReturn(location))),
    hoax:mock(deliv_web_utils,
              ?expect(redirect_302,
                      ?withArgs([location, req2, state]),
                      ?andReturn({ok, req3, state}))),

    Actual = auth_hand_saml_consume:handle(req, state),
    ?assertEqual({ok, req3, state}, Actual),
    ?verifyAll.

handle_when_azure_attributes_present_updates_user() ->
    EntName = <<"testEnt">>,
    UserName = <<"kimmy">>,
    FetchedUser = deliv_user:fromlist([{name, UserName},
                                       {first_name, <<"JP">>},
                                       {last_name, <<"Morgan">>},
                                       {email, <<"JP@chase.com">>}]),
    ExpectedUser = deliv_user:fromlist([{name, UserName},
                                        {first_name, <<"Saml">>},
                                        {last_name, <<"Jackson">>},
                                        {email, <<"saml@saml.io">>}]),
    PropList = [{email, "saml@saml.io"},
                {last_name, "Jackson"},
                {first_name, "Saml"}],
    Cert =  <<"x509abcabcabc">>,
    Relay = [],
    Assertion = #esaml_assertion{recipient = "foo",
                                 issuer = "bomb.com",
                                 subject = #esaml_subject{name = "kimmy"},
                                 attributes = [{emailaddress,"saml@saml.io"},{surname,"Jackson"},{givenname,"Saml"}]},
    hoax:mock(deliv_web_utils,
              ?expect(extract_bindings,
                      ?withArgs([[ent_name], req]),
                      ?andReturn({[EntName], req1}))),
    hoax:mock(auth_saml_cowboy,
              ?expect(extract_saml_params,
                      ?withArgs([req1]),
                      ?andReturn({saml_encoding, saml_response, Relay, req2}))),
    hoax:mock(auth_saml_config, [
              ?expect(identity_provider,
                      ?withArgs([EntName]),
                      ?andReturn({ok,
                                  #esaml_idp_metadata{certificates = [Cert]},
                                  sso_binding,
                                  name_id})),
              ?expect(service_provider,
                      ?withArgs([EntName, [Cert]]),
                      ?andReturn({ok, service_provider_config}))]),
    hoax:mock(auth_saml_cowboy,
              ?expect(validate_assertion,
                      ?withArgs([service_provider_config, saml_encoding, saml_response]),
                      ?andReturn({ok, Assertion}))),
    hoax:mock(deliv_token,
              ?expect(assign_token,
                      ?withArgs([EntName, UserName]),
                      ?andReturn({ok, token}))),
    hoax:mock(deliv_user, [
              ?expect(fetch,
                      ?withArgs([EntName,   UserName]),
                      ?andReturn({ok, FetchedUser})),
              ?expect(getval,
                      ?withArgs([user_type, FetchedUser]),
                      ?andReturn(<<"saml">>)),
              ?expect(update,
                      ?withArgs([ExpectedUser]),
                       ?andReturn({ok, ExpectedUser})),
              ?expect(setvals,
                      ?withArgs([PropList, FetchedUser]),
                      ?andReturn(ExpectedUser))]),
    hoax:mock(auth_saml_utils,
              ?expect(redirect_with_session,
                      ?withArgs([EntName, UserName, token, Relay, req2, state]),
                      ?andReturn({ok, req3, state}))),

    Actual = auth_hand_saml_consume:handle(req, state),
    ?assertEqual({ok, req3, state}, Actual),
    ?verifyAll.

handle_when_assertion_is_valid_relaystate_includes_oidc_redirect_lets_oidc_utils_handle_redirect() ->
    EntName = <<"testEnt">>,
    UserName = <<"kimmy">>,
    Cert =  <<"x509abcabcabc">>,
    User = user_record,
    Assertion = #esaml_assertion{recipient = "foo",
                                 issuer = "bomb.com",
                                 subject = #esaml_subject{name = "kimmy"},
                                 attributes = [{some, <<"thing">>}]},
    Relay = [{oidc_redirect, <<"whatever_the_client_wants_probably_some/callback">>}],
    hoax:mock(deliv_web_utils,
              ?expect(extract_bindings,
                      ?withArgs([[ent_name], req]),
                      ?andReturn({[EntName], req1}))),
    hoax:mock(auth_saml_cowboy,
              ?expect(extract_saml_params,
                      ?withArgs([req1]),
                      ?andReturn({saml_encoding, saml_response, Relay, req2}))),
    hoax:mock(auth_saml_config, [
              ?expect(identity_provider,
                      ?withArgs([EntName]),
                      ?andReturn({ok,
                                  #esaml_idp_metadata{certificates = [Cert]},
                                  sso_binding,
                                  name_id})),
              ?expect(service_provider,
                      ?withArgs([EntName, [Cert]]),
                      ?andReturn({ok, service_provider_config}))]),
    hoax:mock(auth_saml_cowboy,
              ?expect(validate_assertion,
                      ?withArgs([service_provider_config, saml_encoding, saml_response]),
                      ?andReturn({ok, Assertion}))),
    hoax:mock(deliv_user, [
              ?expect(fetch,
                      ?withArgs([EntName, UserName]),
                      ?andReturn({ok, User})),
              ?expect(getval,
                      ?withArgs([user_type, User]),
                      ?andReturn(<<"saml">>)),
              ?expect(setvals,
                      ?withArgs([[], User]),
                      ?andReturn(User)),
              ?expect(update,
                      ?withArgs([User]),
                      ?andReturn({ok, User}))]),
    hoax:mock(auth_oidc_utils, [
              ?expect(redirect_code_request,
                      ?withArgs([Relay, EntName, User, req2, state]),
                      ?andReturn({ok, req3, state}))]),

    Actual = auth_hand_saml_consume:handle(req, state),
    ?assertEqual({ok, req3, state}, Actual),
    ?verifyAll.

handle_when_saml_config_not_present_and_relaystate_includes_oidc_redirect_redirects_to_callback_with_error_parameter() ->
    EntName = <<"testEnt">>,
    Callback = <<"whatever_the_client_wants_probably_some/callback">>,
    ClientState = <<"0123">>,
    ClientId = <<"manage">>,
    Relay = [{oidc_redirect, Callback},
             {oidc_client_id, ClientId},
             {client_state, ClientState}],
    hoax:mock(deliv_web_utils,
              ?expect(extract_bindings,
                      ?withArgs([[ent_name], req]),
                      ?andReturn({[EntName], req1}))),
    hoax:mock(auth_saml_cowboy,
              ?expect(extract_saml_params,
                      ?withArgs([req1]),
                      ?andReturn({saml_encoding, saml_response, Relay, req2}))),
    hoax:mock(auth_saml_config,
              ?expect(identity_provider,
                      ?withArgs([EntName]),
                      ?andReturn({error, not_found}))),
    hoax:mock(auth_oidc_utils, [
              ?expect(extract_client_state,
                      ?withArgs([Relay]),
                      ?andReturn(ClientState)),
              ?expect(redirect_error_response,
                      ?withArgs([ClientId,
                                 Callback,
                                 server_error,
                                 ClientState,
                                 req2, state]),
                      ?andReturn({ok, req3, state}))]),

    Actual = auth_hand_saml_consume:handle(req, state),
    ?assertEqual({ok, req3, state}, Actual),
    ?verifyAll.

handle_when_assertion_is_not_valid_and_relaystate_includes_oidc_redirect_redirects_to_callback_with_error_parameter() ->
    EntName = <<"testEnt">>,
    Callback = <<"whatever_the_client_wants_probably_some/callback">>,
    ClientState = <<"0123">>,
    ClientId = <<"manage">>,
    Relay = [{oidc_redirect, Callback},
             {oidc_client_id, ClientId},
             {client_state, ClientState}],
    Cert =  <<"x509abcabcabc">>,
    hoax:mock(deliv_web_utils,
              ?expect(extract_bindings,
                      ?withArgs([[ent_name], req]),
                      ?andReturn({[EntName], req1}))),
    hoax:mock(auth_saml_cowboy,
              ?expect(extract_saml_params,
                      ?withArgs([req1]),
                      ?andReturn({saml_encoding, saml_response, Relay, req2}))),
    hoax:mock(auth_saml_config, [
              ?expect(identity_provider,
                      ?withArgs([EntName]),
                      ?andReturn({ok,
                                  #esaml_idp_metadata{certificates = [Cert]},
                                  sso_binding,
                                  name_id})),
              ?expect(service_provider,
                      ?withArgs([EntName, [Cert]]),
                      ?andReturn({ok, service_provider_config}))]),
    hoax:mock(auth_saml_cowboy,
              ?expect(validate_assertion,
                      ?withArgs([service_provider_config, saml_encoding, saml_response]),
                      ?andReturn({error, <<"Some failure">>}))),
    hoax:mock(auth_oidc_utils, [
              ?expect(extract_client_state,
                      ?withArgs([Relay]),
                      ?andReturn(ClientState)),
              ?expect(redirect_error_response,
                      ?withArgs([ClientId,
                                 Callback,
                                 access_denied,
                                 ClientState,
                                 req2, state]),
                      ?andReturn({ok, req3, state}))]),

    Actual = auth_hand_saml_consume:handle(req, state),
    ?assertEqual({ok, req3, state}, Actual),
    ?verifyAll.

handle_when_assertion_is_valid_and_no_attributes_present_and_user_not_found_creates_user_and_lets_oidc_utils_handle_redirect() ->
    EntName = <<"testEnt">>,
    UserName = <<"kimmy">>,
    Cert =  <<"x509abcabcabc">>,
    Callback = <<"https://whatever_the_client_wants_probably_some/callback">>,
    ClientState = <<"0123">>,
    ClientId = <<"manage">>,
    Relay = [{oidc_redirect, Callback},
             {oidc_client_id, ClientId},
             {client_state, ClientState}],
    Assertion = #esaml_assertion{recipient = "foo",
                                 issuer = "bomb.com",
                                 subject = #esaml_subject{name = "kimmy"},
                                 attributes = []},
    hoax:mock(deliv_web_utils,
              ?expect(extract_bindings,
                      ?withArgs([[ent_name], req]),
                      ?andReturn({[EntName], req1}))),
    hoax:mock(auth_saml_cowboy,
              ?expect(extract_saml_params,
                      ?withArgs([req1]),
                      ?andReturn({saml_encoding, saml_response, Relay, req2}))),
    hoax:mock(auth_saml_config, [
              ?expect(identity_provider,
                      ?withArgs([EntName]),
                      ?andReturn({ok,
                                  #esaml_idp_metadata{certificates = [Cert]},
                                  sso_binding,
                                  name_id})),
              ?expect(service_provider,
                      ?withArgs([EntName, [Cert]]),
                      ?andReturn({ok, service_provider_config})),
              ?expect(fetch,
                      ?withArgs([EntName]),
                      ?andReturn({ok, #saml_config{default_roles = [<<"observer">>]}}))]),
    hoax:mock(auth_saml_cowboy,
              ?expect(validate_assertion,
                      ?withArgs([service_provider_config, saml_encoding, saml_response]),
                      ?andReturn({ok, Assertion}))),
    hoax:mock(deliv_user, [
              ?expect(fetch,
                      ?withArgs([EntName, UserName]),
                      ?andReturn({error, not_found})),
              ?expect(insert,
                      ?withArgs([EntName, [{name, UserName},
                                           {user_type, <<"saml">>}]]),
                      ?andReturn([user_record])),
              ?expect(edit_roles,
                      ?withArgs([grant, enterprise, [EntName, UserName, [<<"observer">>]]]),
                      ?andReturn(ejson))]),
    hoax:mock(auth_oidc_utils, [
              ?expect(redirect_code_request,
                      ?withArgs([Relay, EntName, user_record, req2, state]),
                      ?andReturn({ok, req3, state}))]),

    Actual = auth_hand_saml_consume:handle(req, state),
    ?assertEqual({ok, req3, state}, Actual),
    ?verifyAll.
